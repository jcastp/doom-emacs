#+title: doom emacs literate config
#+AUTHOR: Javier Castilla
#+EMAIL: jcastp@pm.me
#+startup: overview
#+language: en

* Summary
This is the literate config for my doom emacs use cases.

I will try to document and compartmentalize the sections, so it's easier to follow up, but it won't always be possible, as some functions overlap, and I'm usually a messy person when speaking of testing.

* General
** variable definition
I define here some very basic variables to configure several parts of the config.

*** Directories used by emacs
#+begin_src emacs-lisp
(defvar my-config-dir "~/.doom.d/"
  "Personal config directory.")

(defvar my-data-dir "~/Nextcloud/config/.emacs.d/"
  "Personal data directory.")
#+end_src

*** Machine names
#+begin_src emacs-lisp
;; working laptop vm
(defvar my-worksystem-p (equal (system-name) "lubuntuwork")
  "Name of my working machine.")

;; My desktop machine, able to run anything
(defvar my-desktopsystem-p (or
			    (equal (system-name) "olimpo")
			    (equal (system-name) "doomslayer"))
  "Names of my personal machines.")

;; Writing machines
;; probably we can strip some features from them, as they are low end machines
(defvar my-writinglaptop-p (or
			    (equal (system-name) "argos")
			    (equal (system-name) "caliope"))
  "Names of my writing laptops.")
#+end_src

*** Environments
#+begin_src emacs-lisp
(defvar my-homeenvironment-p (or
			      (string= (getenv "WORKING") "HOME")
			      (not (string= (getenv "WORKING") "WORK")))
  "My home environment predicate.")

(defvar my-workenvironment-p (string= (getenv "WORKING") "WORK")
  "My work environment predicate.")
#+end_src

*** Encrypted data directories
#+begin_src emacs-lisp
;; define my clear directory
(defvar my-clear-directory (expand-file-name "Nextcloud_claro/gocryptfs_claro" (getenv "HOME"))
  "My decrupted directory.")

;; check the directory exists
;;(file-directory-p my-clear-directory)

;; check if a directory is a mount point - against "mount" command in the OS.
(defun is-mount-point-p (path)
  "Check if the given PATH is a mount point."
  (let ((mount-output (shell-command-to-string "mount")))
    (string-match (regexp-quote path) mount-output)))

;; This variable will control if my encrypted dir is mounted on the clear directory
(defvar my-clear-directory-is-mounted-p 0
  "My clear directory is correctly mounted - predicate.")

;; Check if the directory is mounted
(if (is-mount-point-p my-clear-directory)
    ;; if it is mounted, we change the variable
    (setq my-clear-directory-is-mounted-p t)
  ;; if it is not mounted, then we should launch the script here
  (progn
    ;; I think we should not launch this from here, but just examine what is wrong in the OS.
    ;;(shell-command "bash ~/Nextcloud/config/mount-encrypted-dirs.sh")
    )
  )
#+end_src

** Personal information
Based on the environment variables.

This uses a special file, not commited, with my personal information, located in the path below.
It contains the variables =user-full-name= and =user-mail-address=
#+begin_src emacs-lisp
;; to protect my personal information, this file is not commited
(load (expand-file-name "Nextcloud/config/.emacs.d/personal_info.el" (getenv "HOME")))
#+end_src
** Start with a maximized frame
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

** evil-escape mapped to a key chord
#+begin_src emacs-lisp :tangle yes
(after! evil-escape
  (setq evil-escape-key-sequence "jk"))
#+end_src

** Save command history
It is nice to have commands and their history saved so that every time you get back to work, you can just re-run stuff as you need it. It isn't a radical feature, it is just part of a good user experience.

#+begin_src emacs-lisp
(setq savehist-file (expand-file-name "savehist" my-data-dir))
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring)
      )
#+end_src
** auto revert mode
When a file is changed in disk, the buffer reloads to reflect that change.
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
#+end_src

Change dired buffers when the directory is changed:
#+begin_src emacs-lisp
;; auto refresh dired when file changes
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+end_src

** Bookmarks
All the config related to the bookmarks.

#+begin_src emacs-lisp
(setq bookmark-default-file (expand-file-name "bookmarks" my-data-dir))
(setq bookmark-save-flag 1)  ;save bookmarks to .emacs.bmk after each entry
#+end_src

** Abbreviation mode
Defines a set of abbreviations that permits complete words with just some characters.

#+begin_src emacs-lisp
;;where do we read the abbrevs from
(setq abbrev-file-name (expand-file-name "abbrev_defs" my-data-dir))
(setq-default abbrev-mode t)
;; save abbrevs when files are saved
(setq save-abbrevs 'silently)
#+end_src

** electric pair mode
To automatically close parenthesis and other punctuation signs.

#+begin_src emacs-lisp
(electric-pair-mode 1)
;; make electric-pair-mode work on more sets of punctuation signs.
(setq electric-pair-pairs
      '(
        (?\¡ . ?\!)
        (?\¿ . ?\?)
        )
      )

(setq electric-pair-inhibit-predicate
      `(lambda (c)
         (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))
      )
#+end_src

** TODO gptel
https://github.com/karthink/gptel

To interact with ollama local llms.

#+begin_src emacs-lisp
    ;; (if (file-executable-p "~/github/ollama/ollama")
    ;;     (progn
    ;;       (let*
    ;; 	  ;; get all the models we have in this machine
    ;; 	  ((output (shell-command-to-string "~/github/ollama/ollama list | awk '{print $1}' | grep -v NAME"))
    ;; 	   (present_models (split-string output)))
    ;; 	;; body of the let* part
    ;; 	(use-package gptel
    ;; 	  :ensure t
    ;; 	  :config
    ;; 	  ;; Ollama as the default engine
    ;; 	  (setq
    ;; 	   ;;gptel-default-mode 'org-mode
    ;; 	   gptel-model (car present_models)
    ;; 	   gptel-backend (gptel-make-ollama "Ollama"
    ;; 			   :host "localhost:11434"
    ;; 			   :stream t
    ;; 			   :models present_models))))))

  (defun my/gptel ()
    "Start and configure my gptel configuration."
    (interactive)
    ;; Check if the ollama process is running
    (let ((output (shell-command-to-string "ps aux | grep 'ollama serve' | grep -v grep")))
      (if (string-match "github/ollama/ollama serve" output)
          ;; Ollama is running
          (progn
            (message "Ollama is running"))
        ;; Ollama is not running
        (progn
          (shell-command "~/github/ollama/ollama serve&" nil))))
    ;; Check if the ollama binary is executable and configure gptel accordingly
    (if (file-executable-p "~/github/ollama/ollama")
        (let* ((output (shell-command-to-string "~/github/ollama/ollama list | awk '{print $1}' | grep -v NAME"))
              (present_models (split-string output)))
          ;; Configure gptel
          (use-package! gptel
            :config
            ;; Set Ollama as the default engine for gptel
            (setq gptel-model (car present_models)
                  gptel-backend (gptel-make-ollama "Ollama"
                                                    :host "localhost:11434"
                                                    :stream t
                                                    :models present_models))))))
#+end_src

* UI
** ef-themes
Colorful themes.
https://github.com/protesilaos/ef-themes

#+begin_src emacs-lisp :tangle packages.el
(package! ef-themes
  :recipe (:host gitlab :repo "protesilaos/ef-themes"))
#+end_src

** poet theme
https://github.com/kunalb/poet

#+begin_src emacs-lisp :tangle packages.el
(package! poet
  :recipe (:host github :repo "kunalb/poet"))
#+end_src
** doric themes
https://github.com/kunalb/poet

#+begin_src emacs-lisp :tangle packages.el
(package! doric-themes)
#+end_src

** initial theme
#+begin_src emacs-lisp :tangle yes
(setq doom-theme 'ef-dark)
#+end_src

** Establish the default theme
Define some variables with the dark and clear themes, and a variable to control if the current theme is dark or clear.
Also, rotate the list of themes applied.
#+begin_src emacs-lisp :tangle yes
;; define the lists of clear and dark themes
(setq my/themes-dark '(ef-deuteranopia-dark
                       modus-vivendi-tinted))
(setq my/themes-clear '(ef-deuteranopia-light
                        modus-operandi))

;; establish if we start with a dark or clear theme
;; boolean variable: t is dark, nil is clear
(defvar my-theme-dark-p t)

;; define a function to rotate a list. Custom, yes, I know it could be done better.
(defun my/rotate-list (list)
  "Rotate the elements of LIST by one position, moving the first element to the end, and return the new list."
  (if (null list)
      ;; if block
      ;; if the list is empty, returns an empty list
      '()
    ;; else block
    ;; rotates the list
    (append (cdr list) (list (car list)))
    )
  )

;; based on the election, load the theme, and rotate the list for future use.
(with-eval-after-load 'consult
  (if my-theme-dark-p
      ;; dark theme loading
      (progn
        (consult-theme (car my/themes-dark))
        ;; rotate the list - the applied theme goes to the back of the list
        (setq my/themes-dark (my/rotate-list my/themes-dark))
        )
    ;; else block
    ;; clear theme loading
    (progn
      (consult-theme (car my/themes-clear))
      ;; rotate the list - the applied theme goest to the back of the list
      (setq my/themes-clear (my/rotate-list my/themes-clear))
      )
    )
  )
#+end_src

*** Toggle light and dark themes
Function to change between dark and clear themes, based on past variables.
#+begin_src emacs-lisp :tangle yes
(defun my/theme-changer ()
  "Changes themes between clear and dark ones."
  (interactive)
  ;; since we want to change from dark to clear and viceversa, we swap the logic
  (if (not my-theme-dark-p)
      ;; this loads the dark theme
      (progn
        ;;(load-theme (car my/themes-dark) t)
        (consult-theme (car my/themes-dark))
        (message "The theme applied is %s" (car my/themes-dark))
        ;; rotate the list
        (setq my/themes-dark (my/rotate-list my/themes-dark))
        ;; mark the theme is dark now
        (setq my-theme-dark-p t))
    ;; else block (clear theme)
    (progn
      ;;(load-theme (car my/themes-clear) t)
      (consult-theme (car my/themes-clear))
      (message "The theme applied is %s" (car my/themes-clear))
      ;; rotate the list
      (setq my/themes-clear (my/rotate-list my/themes-clear))
      ;; mark the theme is clear now
      (setq my-theme-dark-p nil))))
#+end_src

** Time and date
Put time and date on the status line

#+begin_src emacs-lisp
(setq display-time-day-and-date t
      display-time-24hr-format t)
(display-time)
#+end_src

** Battery management
On laptops it's nice to know how much power you have.

#+begin_src emacs-lisp
(unless (string-match-p "^Power N/A" (battery))
  (display-battery-mode 1)
  )
#+end_src

** Parens mode global
To show matching parens in all the buffers and modes.

#+begin_src emacs-lisp
(show-smartparens-global-mode 1)
#+end_src

** ace-window
To better manage more buffers in screen, as seen here: https://github.com/abo-abo/ace-window

Used in the hydra snippets.
#+begin_src emacs-lisp
(use-package! ace-window
  :config
  (setq aw-scope 'frame)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (global-set-key (kbd "M-o") 'ace-window)
  ;; make the characters bigger, so it is easy to see
  (custom-set-faces
   '(aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 3.0)))))
  )
#+end_src

** beacon
To show the line I am after a long jump.
#+begin_src emacs-lisp :tangle packages.el
(package! beacon
 :recipe (:host github :repo "Malabarba/beacon")
)
#+end_src

#+begin_src emacs-lisp
(use-package! beacon
  :config
  (beacon-mode t)
  (setq beacon-push-mark 35
        beacon-blink-duration 0.5
        beacon-blink-delay 0.5
        beacon-blink-when-focused t
        beacon-color "deep sky blue")
    )
#+end_src

** dimmer
I want to differentiate the window I'm working with.

#+begin_src emacs-lisp :tangle packages.el
(package! dimmer
  :recipe (:host github :repo "gonewest818/dimmer.el"))
#+end_src

#+begin_src emacs-lisp
(dimmer-configure-which-key)
(dimmer-mode t)
(dimmer-configure-magit)
(dimmer-configure-org)

;; configure the dimmer
(setq dimmer-adjustment-mode :both)
(setq dimmer-fraction 0.3)
#+end_src

** Define fonts
#+begin_src emacs-lisp :tangle yes
(setq
  ;; Font used for source code
  ;;doom-font (font-spec :family "Iosevka Comfy" :size 18 :weight 'Medium)

  ;; Font used for normal writing
  ;;doom-variable-pitch-font (font-spec :family "Gentium Basic" :size 18)
  doom-variable-pitch-font (font-spec :family "ETBembo" :size 14)

  ;; When you want to have a different fixed font for the variable one
  ;;doom-variable-pitch-font (font-spec :family "Iosevka Comfy" :size 18 :weight 'Regular)
 )
#+end_src
** Font size increase/decrease
Increase or decrease the font size
#+begin_src emacs-lisp
(global-set-key (kbd "M-+") 'text-scale-increase)
(global-set-key (kbd "M--") 'text-scale-decrease)
#+end_src

** fontaine
I can change the fonts with just a single command.
https://protesilaos.com/emacs/fontaine

#+begin_src emacs-lisp :tangle packages.el
(package! fontaine
  :recipe (:host github :repo "protesilaos/fontaine"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! fontaine
  :config
  (setq fontaine-presets
        '(
          ;; daily operations, same config as normal config
          (regular
           :default-family "DejaVu Sans Mono"
           :default-weight normal
           :default-height 110
           :fixed-pitch-family "DejaVu Sans Mono"
           :fixed-pitch-weight Light ; falls back to :default-weight
           :fixed-pitch-height 110
           :variable-pitch-family "DejaVu Sans Mono"
           :variable-pitch-weight Medium
           :variable-pitch-height 120
           :bold-family nil ; use whatever the underlying face has
           :bold-weight bold
           :italic-family "DejaVu Sans Mono"
           :italic-slant italic
           :line-spacing 0
           )
          ;; Aporetic sans mono font
          (aporetic-sans-mono
           :default-family "Aporetic Sans Mono"
           :default-weight normal
           :default-height 120
           :fixed-pitch-family "Aporetic Sans Mono"
           :fixed-pitch-weight Light ; falls back to :default-weight
           :fixed-pitch-height 110
           :variable-pitch-family "Aporetic Sans"
           :variable-pitch-weight Medium
           :variable-pitch-height 140
           :bold-family nil ; use whatever the underlying face has
           :bold-weight bold
           :italic-family "Aporetic Sans Mono"
           :italic-slant italic
           :line-spacing 0
           )

          ;; work
          (work
           :default-family "Aporetic Sans Mono"
           :default-weight normal
           :default-height 120
           :fixed-pitch-family "Aporetic Sans Mono"
           :fixed-pitch-weight Light ; falls back to :default-weight
           :fixed-pitch-height 110
           :variable-pitch-family "Aporetic Sans"
           :variable-pitch-weight Medium
           :variable-pitch-height 140
           :bold-family nil ; use whatever the underlying face has
           :bold-weight bold
           :italic-family "Aporetic Sans Mono"
           :italic-slant italic
           :line-spacing 0
           )
          )))
#+end_src

* Navigation
** imenu-list
Better menus list

#+begin_src emacs-lisp :tangle packages.el
(package! imenu-list
  :recipe (:host github :repo "bmag/imenu-list"))
#+end_src

#+begin_src emacs-lisp
;; put the imenu in the position we want to
(setq imenu-list-position 'right)
;; Establish the depth of the entries shown
(setq org-imenu-depth 5)
(setq imenu-list-size 0.2)
;; map the keys
;; (global-unset-key (kbd "M-i"))
;;(global-set-key (kbd "C-c s I") #'imenu-list-smart-toggle)
;; Once you open imenu, focus on it
(setq imenu-list-focus-after-activation t)
;; configuring the keybinding as /la/ doom emacs
;; https://rameezkhan.me/posts/2020/2020-07-03--adding-keybindings-to-doom-emacs/
(map! :leader
      :desc "imenu toggle"
      "s I" #'imenu-list-smart-toggle)
#+end_src

** avy keyconfig
I want to map the avy jump functions to some doom emacs keybindings.

#+begin_src emacs-lisp :tangle yes
(map! :leader
      (:prefix-map ("j" . "jump")
       :desc "jump to 2 chars"           "j"   #'avy-goto-char-2
       :desc "jump to chars-timer"       "k"   #'avy-goto-char-timer
       :desc "jump to line"              "l"   #'avy-goto-line))
#+end_src

** Open indirect buffer
Open a branch into a different frame, but the same buffer:

#+begin_src emacs-lisp
;; this is done to open the indirect buffer in another window
;; instead on the main one
(use-package! org
  :config
  (setq org-indirect-buffer-display 'other-window)

  (defun my/org-tree-open-in-right-frame ()
    (interactive)
    (org-tree-to-indirect-buffer)
    ;;(windmove-right)
    (other-window 1) ;; to move to the newly generated window
    )
  ;;(global-set-key (kbd "C-c 8" ) 'my/org-tree-open-in-right-frame)
  (map! :leader
        :desc "Open org tree to indirect buffer"
        "b 8" #'my/org-tree-open-in-right-frame)
  )
#+end_src

* Org config

** some org configs for better behavior and usage
#+begin_src emacs-lisp
(use-package! org
  :config
  (setq
   ;; tag alignment
   ;; this value allows for modern themes and column fill to work well together.
   org-auto-align-tags t
   org-tags-column 0
   ;; org fold - edit in an invisible region
   org-fold-catch-invisible-edits 'show-and-error
   ;; C-a and C-e will move the cursor just the heading. No todo keyworks, no tags
   org-special-ctrl-a/e t
   ;; insert new heading after the current subtree
   org-insert-heading-respect-content t
   ))
#+end_src

** org-id
To create and use internal valid and unique links in org-mode, we will use the =org-id= features.
#+begin_src emacs-lisp
(use-package! org
  :config
  ;; org-id are globally unique UUIDs
  (setq org-id-method 'uuid)
  ;; It will use the CUSTOM_ID, if it exists
  ;;or will create a new one in the form or UUID, as seen above
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  ;; file to store the local =org-id= locations
  ;; This way is synced to all my computers
  (setq org-id-locations-file (expand-file-name "org-id-locations" my-data-dir)))
#+end_src

** Custom states for the tasks
These are the custom states for the tasks, and the character associated to it.

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-todo-keywords
        '(
          ;; Status for tasks
          (sequence "TODO(t)" "ONGOING(o)" "WAITING(w@/!)" "|" "DONE(d!)" "CANCELED(c@/!)")
          ;; Status for writing
          (sequence "TOWRITE(j)" "TOREVIEW(k@/!)" "REDO(l@/!)" "|" "FINISHED(ñ)" "PURGE(p@/!)")
          )
        )
  )
#+end_src

** orgmode Agenda

All the agenda configs

*** Agenda files
We define the agenda files in this variable

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-agenda-files '(
                           ;; normal task files
                           "~/Nextcloud/agenda/tasks.org"
                           ;; added this one to be able to search in it, and add from here to the main task files.
  			   "~/Nextcloud/agenda/someday.org"
                           )
        )
  )
#+end_src

*** icons for the agenda categories
Have some fancy icons for the categories.
#+begin_src emacs-lisp
(use-package! org
  :config
  (customize-set-value
   'org-agenda-category-icon-alist
   `(
     ("calendar" "~/Nextcloud/config/icons/calendar.svg" nil nil :ascent center :mask heuristic)
     ("tasks" "~/Nextcloud/config/icons/check-square.svg" nil nil :ascent center :mask heuristic)
     ("projects" "~/Nextcloud/config/icons/list.svg" nil nil :ascent center :mask heuristic)
     ("financial" "~/Nextcloud/config/icons/dollar-sign.svg" nil nil :ascent center :mask heuristic)
     ("birthdays" "~/Nextcloud/config/icons/heart.svg" nil nil :ascent center :mask heuristic)
     ("revision" "~/Nextcloud/config/icons/shuffle.svg" nil nil :ascent center :mask heuristic)
     ("habits" "~/Nextcloud/config/icons/refresh-ccw.svg" nil nil :ascent center :mask heuristic)
     ("care" "~/Nextcloud/config/icons/heart.svg" nil nil :ascent center :mask heuristic)
     )
   )
  )
#+end_src

*** Get rid of the DONE tasks in the agenda view
We dont want the cluttering in our views. If a task is done, don't show it on the agenda view.

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-timestamp-if-done t)
  )
#+end_src

** export
*** Remove the "validate" link from html exports
#+begin_src emacs-lisp
(use-package! org
  :config
  ;; don't show the "validate" link on org-html exports
  (setq org-html-validation-link nil)
  )
#+end_src

*** Ignore exporting some headlines (just the headlines)
This allows headlines to be ignored in the exports. To do so, the ignore tag (C-c C-c ignore) has to be in the header to be ignored. *We only ignore the headlines, the content is still shown.*

#+begin_src emacs-lisp
(use-package! org
  :config
  (load "~/Nextcloud/config/.emacs.d/vendor/ox-extra/ox-extra.el")
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines))
  )
#+end_src

*** Export to Latex
All the latex exports

**** TODO Memoir class for org2latex (complete these options)
memoir is a class used to create beautiful documents.

#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("memoir"
                 "\\documentclass[a4paper,17pt,openright,twoside]{memoir}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \% Para poner notas en los márgenes
  \\usepackage{todonotes}

  \% Para tachar palabras
  \\usepackage[normalem]{ulem}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  % command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}

  % Chapter style
   \\chapterstyle{dash}

  % How the page is formatted
    \\pagestyle{Ruled}



                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section*{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** TODO Memoir_draft class for org2latex (complete these options)
memoir is a class used to create beautiful documents.

#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("memoir_draft"
                 "\\documentclass[a4paper,17pt,draft,openright,twoside]{memoir}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \% Para poner notas en los márgenes
  \\usepackage{todonotes}

  \% Para tachar palabras
  \\usepackage[normalem]{ulem}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  \% command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}

  \% Chapter style
  \\chapterstyle{dash}

  \% How the page is formatted
  \\pagestyle{Ruled}





                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection*{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection*{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph*{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph*{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** TODO Memoir_chapter class for org2latex (complete these options)
Same as memoir class, but it start just with chapters, no "part"

#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("memoir_chapter"
                 "\\documentclass[a4paper,17pt,openright,twoside]{memoir}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  % Chapter style
   \\chapterstyle{dash}

  % How the page is formatted
    \\pagestyle{Ruled}



                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"

                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section*{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** TODO Memoir_chapter_draft class for org2latex (complete these options)
Same as memoir class, but it start just with chapters, no "part"

#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("memoir_chapter_draft"
                 "\\documentclass[a4paper,17pt,draft,openright,twoside]{memoir}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \% Para poner notas en los márgenes
  \\usepackage{todonotes}

  \% Para tachar palabras
  \\usepackage[normalem]{ulem}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  \% command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}

  \% Chapter style
  \\chapterstyle{dash}

  \% How the page is formatted
  \\pagestyle{Ruled}





                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"

                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection*{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection*{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph*{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph*{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** TODO reporting class for org2latex (complete these options)


#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("reporting"
                 "\\documentclass[a4paper,17pt,openright,twoside]{article}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \% Para poner notas en los márgenes
  \\usepackage{todonotes}

  \% Para tachar palabras
  \\usepackage[normalem]{ulem}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  \% command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}




                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section*{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** Smart quotes
Add smart quotes for latex

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-export-with-smart-quotes t)
  )
#+end_src

** TODO Capture templates
Here I will add template captures for doing several things:

#+begin_src emacs-lisp
  (setq org-capture-templates'(
  			     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                               ;; task related captures

                               ;; ("i" "Inbox" entry
                               ;;   (file+headline "~/Nextcloud/agenda/tasks.org" "Inbox")
                               ;;   "* TODO %i%? "
                               ;;   :empty-lines-after 1)

  			      ("t" "My TODO task format." entry
                                (file+headline "~/Nextcloud/agenda/tasks.org" "Tasks")
                                "** TODO %i%? \n"
                                  :empty-lines-after 1)

  			     ("p" "New project." entry
                                (file+headline "~/Nextcloud/agenda/tasks.org" "Projects")
                                 "** TODO %? \n :PROPERTIES:\n:COOKIE_DATA: todo recursive\n:END:\n   - Objetivo:"
                                :empty-lines-after 1)

  			     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                               ;; Writing related things

  			     ;; Everything that I find interesting to create, no matter what it is
  			     ("h" "Compost heap" item
                                (file+headline "~/Nextcloud/escritura/retazos/compost_heap.org" "Compost heap")
                                 "%i"
                                 :empty-lines-after 1)

  			     ;; A possible writing idea
                               ("w" "Writing idea." entry
                                (file+headline "~/Nextcloud/escritura/retazos/ideas.org" "Ideas")
                                "** TODO %?\n*** Personajes\n- \n*** Ambientación\n*** Eventos\n"
                                :empty-lines-after 1)

                               ;; An interesenting character
                               ("P" "Personaje" entry
                                (file "~/Nextcloud/escritura/retazos/personajes.org")
                                "* %i%?"
                                :empty-lines-after 1)
                               )
        )
  #+end_src

** org-ql
https://github.com/alphapapa/org-ql
#+begin_src emacs-lisp :tangle packages.el
(package! org-ql)
#+end_src
** Capture to this buffer
https://github.com/ballantony/emacs-writing/blob/main/DoomEmacsWriting.org

Used to capture notes in this file. It will create a note under the heading "Notes".
Useful to maintain notes and snippets separated by projects. I will use this for my writing projects.
#+begin_src emacs-lisp
(defun my/capture-to-this-buffer ()
  "Capture note to this buffer"
  (interactive)
  (cond ((not (eq major-mode 'org-mode))
         (message "Can't capture to non org-mode buffer"))
        (t
         (let* ((this-file (buffer-file-name))
                (org-capture-templates
                 `(("t" "Todo" entry (file+headline ,this-file "Notes")
                    "** TODO %?"))))
           (org-capture)))))
#+end_src


** Orgmode org-roam config
Org-roam related config.
*** org-roam general configuration

This is a fix for a Debian installation that doesn't allow to connect directly to the sqlite backend. As seen here: https://github.com/magit/emacsql/blob/main/emacsql-sqlite.el
#+begin_src emacs-lisp
(defun which-linux-distribution ()
  "from lsb_release"
  (interactive)
  (when (eq system-type 'gnu/linux)
    (shell-command-to-string "lsb_release -sd")))

;; (when (string-prefix-p "Debian" (which-linux-distribution))
;;   (use-package sqlite3
;;     :ensure t))
#+end_src

#+begin_src emacs-lisp
  ;; main org-roam config
(use-package! org-roam
  :init
  ;; Create the new directory to store roam notes
  (setq org-roam-directory (file-truename "~/Nextcloud/personal/roam"))
  ;; Location of the roam database
  (setq org-roam-db-location (file-truename "~/Nextcloud/personal/roam/org-roam.db"))
  :config
  ;; provide org-roam completion links outside org files.
  (setq org-roam-completion-everywhere t)
  ;; Ensure the keymap is available
  (require 'org-roam-dailies)
  ;; org-roam export: https://www.orgroam.com/manual.html#org_002droam_002dexport
  (require 'org-roam-export)
  ;; autosync
  (org-roam-db-autosync-mode 1))
#+end_src

Open the fleeting notes with a keybinding:
#+begin_src emacs-lisp
;; (defun my/org-roam-fleeting-notes()
;;   "Open my org-roam file with my fleeting notes"
;;   (interactive)
;;   (find-file "~/Nextcloud/personal/roam/fleeting_notes.org"))
;; (global-set-key (kbd "C-c n F") 'my/org-roam-fleeting-notes)
#+end_src

Org-roam capture templates:
#+begin_src emacs-lisp
;; TODO change these paths to variables: we can try concat or expand-file-name
;; org-roam templates
(setq org-roam-capture-templates
      '(
        ;; default template
        ("d" "default" plain
         "* TODO ${title}\n%?"
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
         :unnarrowed t)
        ("b" "book notes" plain (file "~/.emacs.d/roamtemplates/BookNoteTemplate.org")
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: book")
         :unnarrowed t)
        ("w" "writing idea" plain (file "~/.emacs.d/roamtemplates/WritingIdea.org")
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: writing")
         :unnarrowed t)
        ("c" "writing character" plain (file "~/.emacs.d/roamtemplates/CharacterIdea.org")
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: writing character")
         :unnarrowed t)))
#+end_src

Org-roam window configuration and showing:
#+begin_src emacs-lisp
;; How the roam window shows
;; (add-to-list 'display-buffer-alist
;;              '("\\*org-roam\\*"
;;                (display-buffer-in-side-window)
;;                (side . right)
;;                (slot . 0)
;;                (window-width . 0.33)
;;                (window-parameters . ((no-other-window . t)
;;                                      (no-delete-other-windows . t)))))
#+end_src

Search by title and tags:
#+begin_src emacs-lisp
;; To search by title and tags, we will use the information contained here:
;; https://github.com/org-roam/org-roam/pull/2054
(setq org-roam-node-display-template
      (concat "${title:*} "
              (propertize "${tags:20}" 'face 'org-tag)))
#+end_src

*** org-roam UI
I want to check a graphical view of my notes:
#+begin_src emacs-lisp :tangle packages.el
;; org-roam-ui and its dependencies
;; simple httpd
(package! websocket)
(package! simple-httpd)
(package! org-roam-ui)
#+end_src


#+begin_src emacs-lisp :tangle yes
(use-package! org-roam
  :hook (org-roam . org-roam-ui-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
;; Daily notes for org-roam
;; Directory is relative to org-roam-directory
(setq org-roam-dailies-directory "daily/")


;; Capture template for the dailies
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry
         "* %?"
         :if-new (file+head "%<%Y-%m-%d>.org"
                            "#+title: %<%Y-%m-%d>\n#+filetags: daily\n"))))
#+end_src

*** Restrict agenda to org mode
Functions to isolate the org-roam TODOs from my general agenda.
Extracted from https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html
#+begin_src emacs-lisp
;; I want to get all my org-roam TODOs in the agenda view, but I need to do it only with
;; the files that contain the TODO keywords, and not the whole org-roam directory.

;; https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html

;; we want to load these functions if org-roam is present
(if (not(require 'org-roam nil t))
    ;; if condition
    (message "org-roam not found")
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; else condition

  (setq my/roamtag "roamtag")

  (defun vulpea-buffer-prop-set (name value)
    "Set a file property called NAME to VALUE in buffer file.
      If the property is already set, replace its value."
    (setq name (downcase name))
    (org-with-point-at 1
      (let ((case-fold-search t))
        (if (re-search-forward (concat "^#\\+" name ":\\(.*\\)")
                               (point-max) t)
            (replace-match (concat "#+" name ": " value) 'fixedcase)
          (while (and (not (eobp))
                      (looking-at "^[#:]"))
            (if (save-excursion (end-of-line) (eobp))
                (progn
                  (end-of-line)
                  (insert "\n"))
              (forward-line)
              (beginning-of-line)))
          (insert "#+" name ": " value "\n")))))

  (defun vulpea-buffer-prop-set-list (name values &optional separators)
    "Set a file property called NAME to VALUES in current buffer.
      VALUES are quoted and combined into single string using
      `combine-and-quote-strings'.
      If SEPARATORS is non-nil, it should be a regular expression
      matching text that separates, but is not part of, the substrings.
      If nil it defaults to `split-string-default-separators', normally
      \"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t.
      If the property is already set, replace its value."
    (vulpea-buffer-prop-set
     name (combine-and-quote-strings values separators)))

  (defun vulpea-buffer-tags-set (&rest tags)
    "Set TAGS in current buffer.
        If filetags value is already set, replace it."
    (vulpea-buffer-prop-set "filetags" (string-join tags " ")))

  (defun vulpea-buffer-prop-get (name)
    "Get a buffer property called NAME as a string."
    (org-with-point-at 1
      (when (re-search-forward (concat "^#\\+" name ": \\(.*\\)")
                               (point-max) t)
        (buffer-substring-no-properties
         (match-beginning 1)
         (match-end 1)))))


  (defun vulpea-buffer-prop-get-list (name &optional separators)
    "Get a buffer property NAME as a list using SEPARATORS.
          If SEPARATORS is non-nil, it should be a regular expression
          matching text that separates, but is not part of, the substrings.
          If nil it defaults to `split-string-default-separators', normally
          \"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t."
    (let ((value (vulpea-buffer-prop-get name)))
      (when (and value (not (string-empty-p value)))
        (split-string-and-unquote value separators))))

  (defun vulpea-buffer-tags-get ()
    "Return filetags value in current buffer."
    (vulpea-buffer-prop-get-list "filetags" " "))

  (defun vulpea-buffer-tags-add (tag)
    "Add a TAG to filetags in current buffer."
    (let* ((tags (vulpea-buffer-tags-get))
           (tags (append tags (list tag))))
      (apply #'vulpea-buffer-tags-set tags)))



  (defun vulpea-project-p ()
    "Return non-nil if current buffer has any todo entry.

              TODO entries marked as done are ignored, meaning the this
              function returns nil if current buffer contains only completed
              tasks."
    (seq-find                                 ; (3)
     (lambda (type)
       (eq type 'todo))
     (org-element-map                         ; (2)
         (org-element-parse-buffer 'headline) ; (1)
         'headline
       (lambda (h)
         (org-element-property :todo-type h)))))

  (defun vulpea-project-update-tag ()
    "Update PROJECT tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (vulpea-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (vulpea-buffer-tags-get))
               (original-tags tags))
          (if (vulpea-project-p)
              (setq tags (cons "roamtag" tags))
            (setq tags (remove "roamtag" tags)))

          ;; cleanup duplicates
          (setq tags (seq-uniq tags))

          ;; update tags if changed
          (when (or (seq-difference tags original-tags)
                    (seq-difference original-tags tags))
            (apply #'vulpea-buffer-tags-set tags))))))

  (defun vulpea-buffer-p ()
    "Return non-nil if the currently visited buffer is a note."
    (and buffer-file-name
         (string-prefix-p
          (expand-file-name (file-name-as-directory org-roam-directory))
          (file-name-directory buffer-file-name))))

  (defun vulpea-project-files ()
    "Return a list of note files containing 'roamtag' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
        :from tags
        :left-join nodes
        :on (= tags:node-id nodes:id)
        :where (like tag (quote "%\"roamtag\"%"))]))))




  ;; ---------------------------------
  ;; this is the agenda part

  ;; This will overwrite the current agenda files, and we don't want that
  ;; (defun vulpea-agenda-files-update (&rest _)
  ;;   "Update the value of `org-agenda-files'."
  ;;   (setq org-agenda-files (vulpea-project-files)))

  ;; (defun inject-vulpea-project-files (org-agenda-files)
  ;;   (append org-agenda-files (vulpea-project-files)))
  ;; (advice-add 'org-agenda-files :filter-return #'inject-vulpea-project-files)

  (add-hook 'find-file-hook #'vulpea-project-update-tag)
  (add-hook 'before-save-hook #'vulpea-project-update-tag)

  ;; ;; original code that overwrites the agenda files (using the one above, this one is just for training)
  ;;  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
  ;;  (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)
  )
#+end_src

Just show the TODOs from org-roam, and not from the general agenda.

#+begin_src emacs-lisp
(defun my/agenda-restrict-to-roam ()
  "Restrict agenda to current project"
  (interactive)
  (let ((org-agenda-files (list org-roam-directory)))
    (org-agenda)))
;;(global-set-key (kbd "C-c n a") 'my/agenda-restrict-to-roam)
#+end_src

*** org-roam random node opening
Opens a random org-roam node.

#+begin_src emacs-lisp
(defun my/random-roam-node ()
  "Opens a random org-roam node."
  (interactive)
  (setq todo-nodes
        (org-roam-db-query
         ;; select the nodes that have the roamtag tag
         [:select [nodes:file]
          :from tags
          :left-join nodes
          :on (= tags:node-id nodes:id)
  	  ]
  	 )
        )
  ;; get a random file from the list and open it
  (find-file (car (nth (random (length todo-nodes)) todo-nodes))))

;; (global-set-key (kbd "C-c n R") 'my/random-roam-node)
#+end_src

Open a random roam node with the roamtag tag (that maps to a TODO entry).
#+begin_src emacs-lisp
(defun my/random-roam-todo-node ()
  "Opens a random org-roam node with the roamtag tag."
  (interactive)
  (setq todo-nodes
        (org-roam-db-query
         ;; select the nodes that have the roamtag tag
         [:select [nodes:file]
          :from tags
          :left-join nodes
          :on (= tags:node-id nodes:id)
          :where (like tag (quote "%\"roamtag\"%"))])
        )
  ;; get a random file from the list and open it
  (find-file (car (nth (random (length todo-nodes)) todo-nodes))))

;; (global-set-key (kbd "C-c n T") 'my/random-roam-todo-node)
#+end_src

* Writing
** org-journal
This is for journaling every day, if possible.
Documentation can be found here:

https://github.com/bastibe/org-journal

#+begin_src emacs-lisp
;;("C-c r ñ" . org-journal-new-entry)
(use-package! org-journal
  :config
  (setq org-journal-date-prefix "#+TITLE: ")
  (setq org-journal-file-format "%Y-%m-%d.org")
  ;;(setq org-journal-dir "~/Nextcloud/personal/diario/")
  (setq org-journal-dir (expand-file-name "personal/diario" my-clear-directory))
  (setq org-journal-date-format "%A, %d %B %Y")
  (setq org-journal-encrypt-journal nil)
  )
#+end_src

** Buscar en la RAE
Seach a word in the spanish dictionary.

#+begin_src emacs-lisp
(defun my/buscarae (palabra)
  "Busca una palabra en la RAE."
  (interactive "s¿Qué palabra quieres buscar? ")
  (eww (concat "https://dle.rae.es/" palabra))
  )
#+end_src

** Buscar sinónimos
Seach a synonim.

#+begin_src emacs-lisp
(defun my/sinonimo (palabra)
  "Busca una palabra en un diccionario de sinónimos"
  (interactive "s¿Qué palabra quieres buscar? ")
  (eww (concat "https://www.wordreference.com/sinonimos/" palabra))
  )
#+end_src

** Translate from english
Translate a word

#+begin_src emacs-lisp
(defun my/translate (palabra)
  "Traduccion de inglés a español"
  (interactive "s¿Qué palabra quieres buscar? ")
  (eww (concat "https://www.deepl.com/translator#en/es/" palabra))
  )
#+end_src
** Buscar sinónimos
Seach for synonyms for Spanish words.

#+begin_src emacs-lisp
  (defun my/sinonimo (palabra)
    "Busca una palabra en un diccionario de sinónimos"
    (interactive "s¿Qué palabra quieres buscar? ")
    (eww (concat "https://www.wordreference.com/sinonimos/" palabra)))
#+end_src

** TODO Count words in orgmode, excluding comments, drawers, and properties
=count-words= function is good, but in orgmode still counts all the words, including comments, properties, and drawers.

These functions avoid that.

# TODO
# - Do not count words inside #+begin_comment delimiters

#+begin_src emacs-lisp
(defun org-in-commented-line ()
  "Return non-nil if point is in a commented line."
  (save-excursion
    (beginning-of-line)
    (looking-at-p "^[ \t]*#")))

(defun org-in-drawer-p ()
  "Return non-nil if point is in an Org mode drawer."
  (save-excursion
    (beginning-of-line)
    (looking-at-p "^[ \t]*:[a-zA-Z]+:")))

(defun org-at-property-p ()
  "Return non-nil if point is at an Org mode property."
  (save-excursion
    (beginning-of-line)
    (looking-at-p "^[ \t]*:[a-zA-Z]+:")))

(defun my/org-count-words (&optional begin end)
  "Count words in the region if active, or the whole buffer if not.
Ignores Org mode comments, drawers, and properties."
  (interactive)
  (let ((begin (or begin (if (use-region-p) (region-beginning) (point-min))))
        (end (or end (if (use-region-p) (region-end) (point-max))))
        (word-count 0))
    (save-excursion
      (goto-char begin)
      (while (re-search-forward "\\w+" end t)
        (unless (or (org-in-commented-line)
                    (org-in-drawer-p)
                    (org-at-property-p))
          (setq word-count (1+ word-count)))))
    (message "Word count: %d" word-count)
    word-count))
#+end_src

** TODO Add a property for orgmode headings with an advanced word count function
Modified the Emacs Writing Studio ([[https://github.com/pprevos/emacs-writing-studio][EWS]]) function to use my orgmode word count function.
It adds a property, called WORDCOUNT, to the headings so we can leverage in reports or other actions.
It also adds a custom id under every org heading, so we can link back to it.

#+begin_src emacs-lisp
  (defun my/ews-org-count-words ()
  "Add word count to each heading property drawer in an Org mode buffer."
  (interactive)
  (org-map-entries
   (lambda ()
     (let* ((start (point))
            (end (save-excursion (org-end-of-subtree)))
            (word-count (my/org-count-words start end)))
       (org-set-property "WORDCOUNT" (number-to-string word-count)))
     ;; create the id to link the org heading
     (org-id-get-create))))
#+end_src

** TODO Dynamic block function to draw the wordcount of the sections
This function relies on a property in the org-heading called WORDCOUNT, that is generated by the function =my/ews-org-count-words=. It will draw a sorted table with the word count of each section.

# TODOs
# - Solve the issue for multiple asterisks being formated as bold
# - Add a keyword to add the tags we want to exclude

#+begin_src emacs-lisp
  (defun org-dblock-write:org-generate-wordcount-table (params)
    "Generate a table with heading names and their WORDCOUNT property in Org mode."
    (interactive)
    ;; We execute the function of counting words, add the WORDCOUNT property,
    ;; and update the current word count.
    (my/ews-org-count-words)
    (let (table-data)
      ;; Traverse each Org entry in the current buffer
      (org-map-entries
       (lambda ()
         (let* ((heading-components (org-heading-components))
                (heading (nth 4 heading-components))  ; Extract heading text
                (level (car heading-components)) ;Extract level
  	      (tags (org-get-tags))
                (wordcount (org-entry-get nil "WORDCOUNT")))
  	 ;; check if we get tags, and if they don't contain the noexport
  	 (if (not (and tags (member "noexport" tags)))
  	   ;; add the data in the table-data for each heading
  	   (push (cons
  		  ;; add the asterisks (ascii 42), the space (ascii 32) and the heading
  		  (format "%s%s%s" (make-string level 42) (make-string 1 32) (org-link-make-string heading))
  		  ;; add the wordcount
  		  wordcount)
  		 ;; add all to the table-data
  		 table-data)))))
      (insert "| Heading         | Wordcount |\n"
              "|-----------------+-----------|\n")
      (dolist (pair (reverse table-data))
        (insert (format "| %s | %s |\n" (car pair) (cdr pair)))
        (org-table-align))))
#+end_src

* Testing
** TODO elfeed and elfeed-org
Configuration for the elfeed and the org files.
#+begin_src emacs-lisp
;; database for elfeed
(use-package! elfeed
  :config
  (elfeed-org)
  (setq elfeed-db-directory (expand-file-name "elfeed/db/" my-data-dir))

  ;; Optionally specify a number of files containing elfeed
  ;; configuration. If not set then the location below is used.
  ;; Note: The customize interface is also supported.
  (setq rmh-elfeed-org-files (list "~/Nextcloud/config/.emacs.d/elfeed/elfeed.org"))
  ;; put the filter to 1 month ago by default
  (setq elfeed-search-set-filter "@1-month-ago")

  ;; open elfeed and update it
  (defun my/elfeed()
    "Opens elfeed and updates it in just a go."
    (interactive)
    (elfeed)
    (elfeed-update)))
#+end_src

** Nov.el
Read e-pub in emacs.

https://tech.toryanderson.com/2022/11/23/viewing-epub-in-emacs/

#+begin_src emacs-lisp :tangle packages.el
  (package! esxml
    :recipe (:host github :repo "tali713/esxml"))

   (package! nov
     :recipe (:host nil :repo "https://depp.brause.cc/nov.el.git"))
#+end_src


#+begin_src emacs-lisp
(use-package! nov
     :config
     (setq nov-text-width 100)
     ;;(setq nov-text-width t)
     (setq visual-fill-column-center-text t)
     (add-hook 'nov-mode-hook 'visual-line-mode)
     (add-hook 'nov-mode-hook 'visual-fill-column-mode)
     ;; We save the place we left the e-pub in this file:
     (setq nov-save-place-file (expand-file-name "nov-places" my-data-dir))
    (defun my/nov-font-setup ()
      (face-remap-add-relative 'variable-pitch :family "Gentium"
                                :height 1.2))
     (add-hook 'nov-mode-hook 'my/nov-font-setup)
     (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
     )
#+end_src

* My custom key bindings
This is where I'm going to define my own keybindings.

I use one of the free prefixes, SPC d, to map my own functions, the ones I will be using more.
#+begin_src emacs-lisp :tangle yes
(map! :leader
      (:prefix-map ("d" . "my own functions")
       :desc "capture to this buffer"  "c"  #'my/capture-to-this-buffer
       :desc "elfeed"                  "e"  #'my/elfeed
       :desc "fontaine preset"         "f"  #'fontaine-set-preset
       :desc "theme changer"           "0"  #'my/theme-changer
       ))
#+end_src

Mapping my org roam functions:
- my random roam node
- my random todo roam node
- my agenda restricted to roam

#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "random todo roam node"      "m m t" #'my/random-roam-todo-node
      :desc "random roam node"           "m m T" #'my/random-roam-node
      :desc "roam agenda"                "m m a" #'my/agenda-restrict-to-roam
      )
#+end_src
* Work environment
This will be my working environment config

#+begin_src emacs-lisp
;; Load this config when using the work computer
(if my-workenvironment-p
    (progn
      (org-babel-load-file "~/.doom.d/emacs-org-init-trabajo.org")))
#+end_src
