#+TITLE: doom personal config
#+AUTHOR: Javier Castilla
#+EMAIL: jcastp@pm.me
#+startup: overview
#+language: en

* Summary
This is the literate config for my doom emacs use cases.

I will try to document and compartmentalize the sections, so it's easier to follow up, but it won't always be possible, as some functions overlap, and I'm usually a messy person when speaking of testing.

* General config
** System information
Variables to conditional load based on systems or locations.

*** based on machine names
Defining variables for conditional execution, based on machines:

#+begin_src emacs-lisp
;; working laptop vm
(defvar my-worksystem-p (equal (system-name) "lubuntuwork"))
;; My desktop machine, able to run anything
(defvar my-desktopsystem-p (or
			    (equal (system-name) "olimpo")
			    (equal (system-name) "doomslayer")))
;; Writing machines
;; probably we can strip some features from them, as they are low end machines
(defvar my-writinglaptop-p (or
			    (equal (system-name) "argos")
			    (equal (system-name) "caliope")))

(defvar my-homeenvironment-p (or
			      (string= (getenv "WORKING") "HOME")
			      (not (string= (getenv "WORKING") "WORK")))
  )
(defvar my-workenvironment-p (string= (getenv "WORKING") "WORK"))
#+end_src

*** based on environment variables
Home and Work environment.

#+begin_src emacs-lisp
(defvar my-workenvironment-p (string= (getenv "WORKING") "WORK"))
(defvar my-homeenvironment-p (string= (getenv "WORKING") "HOME"))
#+end_src

*** Define my clear directory
#+begin_src emacs-lisp
;; define my clear directory
(setq my-clear-directory (expand-file-name "Nextcloud_claro/gocryptfs_claro" (getenv "HOME")))

;; check the directory exists
;;(file-directory-p my-clear-directory)

;; check if a directory is a mount point - against "mount" command in the OS.
(defun is-mount-point-p (path)
  "Check if the given PATH is a mount point."
  (let ((mount-output (shell-command-to-string "mount")))
    (string-match (regexp-quote path) mount-output)))

;; This variable will control if my encrypted dir is mounted on the clear directory
(defvar my-clear-directory-is-mounted-p 0
  "My clear directory is correctly mounted")

;; Check if the directory is mounted
(if (is-mount-point-p my-clear-directory)
    ;; if it is mounted, we change the variable
    (setq my-clear-directory-is-mounted-p t)
  ;; if it is not mounted, then we should launch the script here
  (progn
    ;; I think we should not launch this from here, but just examine what is wrong in the OS.
    ;;(shell-command "bash ~/Nextcloud/config/mount-encrypted-dirs.sh")
    )
  )
#+end_src

** Personal information
Based on the environment variables.

This uses a special file, not commited, with my personal information, located in the path below.
It contains the variables =user-full-name= and =user-mail-address=
#+begin_src emacs-lisp
;; to protect my personal information, this file is not commited
(load (expand-file-name "Nextcloud/config/.emacs.d/personal_info.el" (getenv "HOME")))
#+end_src

** Configure the config and data directories
- Config directory contains the files that will be committed. All the files that will get emacs up and running will be here.
- Data directory contains the files that should no be committed, but contains my own information, that is useful.
We will be using this either with concat or expand-file-name:
- expand-file-name for when we have just a filename
- concat for when we have a composite directory and filename, or as a secondary way to do it.
  
#+begin_src emacs-lisp
;; this is the same as the doom-user-dir
(defvar my-config-dir "~/.doom.d/")
;; where the files I can sync live
(defvar my-data-dir "~/Nextcloud/config/.emacs.d/")
#+end_src

** Don't show compile warnings
#+begin_src emacs-lisp
(setq byte-compile-warnings nil)
#+end_src
** Start with a maximized frame
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

** Unmap the C-z key

Unmap the C-z key, so no way to minimize or suspend emacs accidentally.
#+begin_src emacs-lisp
  (global-unset-key (kbd "C-z"))
#+end_src
** Network security set to high
Enforcing the network security.
https://www.gnu.org/software/emacs/manual/html_node/emacs/Network-Security.html
#+begin_src emacs-lisp
  (setq network-security-level 'high)
#+end_src

** Movement
Some keys redefined to better adjust to the whole emacs key environment.
#+begin_src emacs-lisp
(global-set-key (kbd "M-p") 'backward-paragraph)
(global-set-key (kbd "M-n") 'forward-paragraph)
#+end_src

** Save command history
It is nice to have commands and their history saved so that every time you get back to work, you can just re-run stuff as you need it. It isn't a radical feature, it is just part of a good user experience.

#+begin_src emacs-lisp
(setq savehist-file (expand-file-name "savehist" my-data-dir))
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring)
      )
#+end_src

** free-keys
To know which keys are still free.

#+begin_src emacs-lisp :tangle packages.el
(package! free-keys
  :recipe (:host github :repo "Fuco1/free-keys"))
#+end_src

** auto revert mode
When a file is changed in disk, the buffer reloads to reflect that change.
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
#+end_src

Change dired buffers when the directory is changed:
#+begin_src emacs-lisp
;; auto refresh dired when file changes
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+end_src

** Bookmarks
All the config related to the bookmarks.

#+begin_src emacs-lisp
(setq bookmark-default-file (expand-file-name "bookmarks" my-data-dir))
(setq bookmark-save-flag 1)  ;save bookmarks to .emacs.bmk after each entry
#+end_src

** recentf
#+begin_src emacs-lisp
;; where to store the recent list file
(setq recentf-save-file (expand-file-name "recentf" my-data-dir))
(recentf-mode 1)
;;(global-set-key (kbd "C-c d r") #'recentf)
(map! :leader
      :desc "Recent files list"
      "d r" #'recentf)
#+end_src

** Abbreviation mode
Defines a set of abbreviations that permits complete words with just some characters.

#+begin_src emacs-lisp
;;where do we read the abbrevs from
(setq abbrev-file-name (expand-file-name "abbrev_defs" my-data-dir))
(setq-default abbrev-mode t)
;; save abbrevs when files are saved
(setq save-abbrevs 'silently)
#+end_src

** electric pair mode
To automatically close parenthesis and and other punctuation signs.

#+begin_src emacs-lisp
(electric-pair-mode 1)
;; make electric-pair-mode work on more sets of punctuation signs.
(setq electric-pair-pairs
      '(
        (?\¡ . ?\!)
        (?\¿ . ?\?)
        )
      )

(setq electric-pair-inhibit-predicate
      `(lambda (c)
         (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))
      )
#+end_src

** persp-save location
#+begin_src emacs-lisp
(use-package! persp-mode
  :config
  (setq persp-save-dir (expand-file-name "persp-confs/" my-data-dir))
)
#+end_src

** set firefox as the default browser
Setting firefox as the default browser for opening http/s links.
#+begin_src emacs-lisp
(setq browse-url-firefox-program "firefox")
(setq browse-url-browser-function 'browse-url-firefox)
#+end_src

* UI
** Define fonts
Define the fonts for Doom emacs.
There are fixed and variable pitch fonts to define.

#+begin_src emacs-lisp
(setq
  ;; Font used for source code
  ;;doom-font (font-spec :family "JetBrains Mono" :size 14 :weight 'Medium)
  ;;doom-font (font-spec :family "Fira Code" :size 14 :weight 'Medium)
  ;; doom-font (font-spec :family "Hasklig" :size 16 :weight 'Medium)
  ;;doom-font (font-spec :family "Iosevka Fixed" :size 16 :weight 'Medium)
  doom-font (font-spec :family "Iosevka Comfy" :size 18 :weight 'Medium)
  ;; doom-font (font-spec :family "Hack" :size 14)

  ;; Font used for normal writing
  ;;doom-variable-pitch-font (font-spec :family "Gentium Basic" :size 18)
  ;;doom-variable-pitch-font (font-spec :family "ETBookOT" :size 18)
  ;;doom-variable-pitch-font (font-spec :family "ETBembo" :size 18)

  ;;;; When you want to have a fixed font for the variable one
  ;;doom-variable-pitch-font (font-spec :family "Fira Code" :size 14 :weight 'Medium)
  ;;doom-variable-pitch-font (font-spec :family "JetBrains Mono" :size 16 :weight 'Extralight)
  ;;doom-variable-pitch-font (font-spec :family "JetBrains Mono" :size 18 :weight 'Light)
  doom-variable-pitch-font (font-spec :family "Iosevka Comfy" :size 18 :weight 'Regular)
  ;;doom-variable-pitch-font (font-spec :family "Iosevka")
  )
#+end_src

For when I want mixed pitch mode in org mode.

#+begin_src emacs-lisp
;;(add-hook! 'org-mode-hook #'mixed-pitch-mode)
#+end_src

** fontaine
I can change the fonts with just a single command.
https://protesilaos.com/emacs/fontaine

#+begin_src emacs-lisp :tangle packages.el
(package! fontaine
  :recipe (:host github :repo "protesilaos/fontaine"))
#+end_src

Here will come the code for the fontaine package.
#+begin_src emacs-lisp
(use-package! fontaine
  :config
  (setq fontaine-presets
      '(
        ;; daily operations, same config as normal config
            (regular
             :default-family "Iosevka"
             :default-weight normal
             :default-height 120
             :fixed-pitch-family "Iosevka"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 110
             :variable-pitch-family "Iosevka Comfy"
             :variable-pitch-weight Medium
             :variable-pitch-height 120
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "Iosevka"
             :italic-slant italic
             :line-spacing 0
             )
            (regular-comfy
             :default-family "Iosevka Comfy"
             :default-weight normal
             :default-height 120
             :fixed-pitch-family "Iosevka Comfy"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 110
             :variable-pitch-family "Iosevka Comfy"
             :variable-pitch-weight Medium
             :variable-pitch-height 120
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "Iosevka Comfy"
             :italic-slant italic
             :line-spacing 0
             )
            ;; Bigger face for variable width, so I can focus on it
            (writing
             :default-family "ETBembo"
             :default-weight normal
             :default-height 150
             :fixed-pitch-family "Iosevka"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 120
             :variable-pitch-family "ETBembo"
             :variable-pitch-weight Medium
             :variable-pitch-height 150
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "ETBembo"
             :italic-slant italic
             :line-spacing 1
             )
            ;; Bigger face for variable width, so I can focus on it
            (writing-big
             :default-family "ETBembo"
             :default-weight normal
             :default-height 180
             :fixed-pitch-family "Iosevka"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 140
             :variable-pitch-family "ETBembo"
             :variable-pitch-weight Medium
             :variable-pitch-height 180
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "ETBembo"
             :italic-slant italic
             :line-spacing 1
             )
            ;; change the variable width face to have a different view when editing
            (editing
             :default-family "Iosevka"
             :default-weight normal
             :default-height 130
             :fixed-pitch-family "Iosevka"
             :fixed-pitch-weight nil ; falls back to :default-weight
             :fixed-pitch-height 110
             :variable-pitch-family "Gentium"
             :variable-pitch-weight normal
             :variable-pitch-height 150
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "Gentium"
             :italic-slant italic
             :line-spacing 1
             )
  	  ;; font for work
  	  (work
             :default-family "Iosevka"
             :default-weight normal
             :default-height 140
             :fixed-pitch-family "Iosevka"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 110
             :variable-pitch-family "Iosevka Comfy"
             :variable-pitch-weight Medium
             :variable-pitch-height 140
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "Iosevka"
             :italic-slant italic
             :line-spacing 0
             )

        )
      )
)
#+end_src

** ef-themes
Colorful themes.
https://github.com/protesilaos/ef-themes

#+begin_src emacs-lisp :tangle packages.el
(package! ef-themes
  :recipe (:host gitlab :repo "protesilaos/ef-themes"))
#+end_src

** Protesilaos modus themes
Protesilaos very good themes. These themes are already included in the standard emacs, so we can get rid of the use-package definition, and retain only the config.

#+begin_src emacs-lisp
  ;;  (use-package modus-themes
  ;;    :ensure t
  ;;    :init
      ;; Add all your customizations prior to loading the themes
      (setq
       modus-themes-completions nil
       modus-themes-bold-constructs t
       modus-themes-italic-constructs t
       modus-themes-success-deuteranopia t
       modus-themes-mixed-fonts t
       modus-themes-intense-markup t
       modus-themes-tabs-accented t
       modus-themes-org-blocks '(tinted-background)
       modus-themes-variable-pitch-ui nil
       modus-themes-variable-pitch-headings nil

       modus-themes-fringes nil ; {nil,'subtle,'intense}

       ;; fonts for headings
       modus-themes-headings
       '((1 . (background overline rainbow 1.10))
         (2 . (overline rainbow 1.05))
         (3 . (rainbow 1.1))
         (4 . (rainbow no-bold 1.0))
         (t . (monochrome no-bold 1.0)))
       ;; scales up the headings
       modus-themes-scale-headings t
       )
#+end_src

** poet theme
https://github.com/kunalb/poet

#+begin_src emacs-lisp :tangle packages.el
(package! poet
  :recipe (:host github :repo "kunalb/poet"))
#+end_src

** Initial theme
We establish the initial theme.

#+begin_src emacs-lisp
(consult-theme 'doom-vibrant)
#+end_src

** TODO Theme changer
Define some variables with the dark and clear themes, and a variable to control if the current theme is dark or clear.
Also, rotate the list of themes applied.

#+begin_src emacs-lisp
;; define the lists of clear and dark themes
(setq my/themes-dark '(ef-deuteranopia-dark
                       modus-vivendi))
(setq my/themes-clear '(ef-deuteranopia-light
                        modus-operandi))

;; establish if we start with a dark or clear theme
;; boolean variable: t is dark, nil is clear
(defvar my-theme-dark-p t)

;; define a function to rotate a list. Custom, yes, I know it could be done better.
(defun my/rotate-list (list)
  "Rotate the elements of LIST by one position, moving the first element to the end, and return the new list."
  (if (null list)
      ;; if block
      ;; if the list is empty, returns an empty list
      '()
    ;; else block
    ;; rotates the list
    (append (cdr list) (list (car list)))
    )
  )

;; based on the election, load the theme, and rotate the list for future use.
(with-eval-after-load 'consult
  (if my-theme-dark-p
      ;; dark theme loading
      (progn
        (consult-theme (car my/themes-dark))
        ;; rotate the list - the applied theme goes to the back of the list
        (setq my/themes-dark (my/rotate-list my/themes-dark))
        )
    ;; else block
    ;; clear theme loading
    (progn
      (consult-theme (car my/themes-clear))
      ;; rotate the list - the applied theme goest to the back of the list
      (setq my/themes-clear (my/rotate-list my/themes-clear))
      )
    )
  )
#+end_src
*** Toggle light and dark themes
Function to change between dark and clear themes, based on past variables.
#+begin_src emacs-lisp
(with-eval-after-load 'consult
  (defun my/theme-changer ()
    "Changes themes between clear and dark ones."
    (interactive)
    ;; here there will be the code for changing the themes

    ;; since we want to change from dark to clear and viceversa, we swap the logic
    (if (not my-theme-dark-p)
        ;; this loads the dark theme
        (progn
          ;;(load-theme (car my/themes-dark) t)
          (consult-theme (car my/themes-dark))
          (message "The theme applied is %s" (car my/themes-dark))
          ;; rotate the list
          (setq my/themes-dark (my/rotate-list my/themes-dark))
          ;; mark the theme is dark now
          (setq my-theme-dark-p t)

          )
      ;; else block (clear theme)
      (progn
        ;;(load-theme (car my/themes-clear) t)
        (consult-theme (car my/themes-clear))
        (message "The theme applied is %s" (car my/themes-clear))
        ;; rotate the list
        (setq my/themes-clear (my/rotate-list my/themes-clear))
        ;; mark the theme is clear now
        (setq my-theme-dark-p nil)
        )
      )
    )
  )

(global-set-key (kbd "C-c 0") 'my/theme-changer)
#+end_src

** Fontify the header
Fontify the whole line for headings (with a background color). Works well with Leuven theme:

#+begin_src emacs-lisp
(setq org-fontify-whole-heading-line t)
#+end_src

Different sizes for the different org headings.
#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 `(org-level-4 ((t (:height 1.0))))
 `(org-level-3 ((t (:height 1.1))))
 `(org-level-2 ((t (:height 1.2))))
 `(org-level-1 ((t (:height 1.35))))
 `(org-document-title ((t (:height 1.6 :underline nil))))
 )
#+end_src

** full path in the title bar
Put the complete path on the title bar, along the filename.

#+begin_src emacs-lisp
(setq-default frame-title-format "%b - (%f)")
#+end_src

** Time and date
Put time and date on the status line

#+begin_src emacs-lisp
(setq display-time-day-and-date t
      display-time-24hr-format t)
(display-time)
#+end_src

** Open indirect buffer
Open a branch into a different frame, but the same buffer:

#+begin_src emacs-lisp
;; this is done to open the indirect buffer in another window
;; instead on the main one
(use-package! org
  :config
  (setq org-indirect-buffer-display 'other-window)

  (defun my/org-tree-open-in-right-frame ()
    (interactive)
    (org-tree-to-indirect-buffer)
    ;;(windmove-right)
    (other-window 1) ;; to move to the newly generated window
    )
  ;;(global-set-key (kbd "C-c 8" ) 'my/org-tree-open-in-right-frame)
  (map! :leader
        :desc "Open org tree to indirect buffer"
        "b 8" #'my/org-tree-open-in-right-frame)
  )
#+end_src

** Battery management
On laptops it's nice to know how much power you have.

#+begin_src emacs-lisp
(unless (string-match-p "^Power N/A" (battery))
  (display-battery-mode 1)
  )
#+end_src

** Long lines get wrapped
Long lines get wrapped when they reach the edge. We activate it for all the buffers.

#+begin_src emacs-lisp
;; 1 for on, 0 for off.
(global-visual-line-mode 1)
#+end_src

** Fill column mode
We want to use the visual fill column mode to limit the width of the lines, even if they don't reach the right edge.

When reaching the established width defined, the line will wrap, even before getting into the right border of the application.

#+begin_src emacs-lisp :tangle packages.el
(package! visual-fill-column
  :recipe (:host codeberg :repo "joostkremers/visual-fill-column"))
#+end_src

#+begin_src emacs-lisp
;; This sets the value to all the buffers, as initially it is a per-buffer variable
(setq-default visual-fill-column-width 110)
;; enable it only for text buffers: org, text, ...
(add-hook 'text-mode-hook 'visual-fill-column-mode)
#+end_src

** Parens mode global
To show matching parens in all the buffers and modes.

#+begin_src emacs-lisp
(show-smartparens-global-mode 1)
#+end_src

** ace-window
To better manage more buffers in screen, as seen here: https://github.com/abo-abo/ace-window

Used in the hydra snippets.
#+begin_src emacs-lisp
(use-package! ace-window
  :config
  (setq aw-scope 'frame)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (global-set-key (kbd "M-o") 'ace-window)
  ;; make the characters bigger, so it is easy to see
  (custom-set-faces
   '(aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 5.0)))))
  )
#+end_src

** beacon
To show the line I am after a long jump.
#+begin_src emacs-lisp :tangle packages.el
(package! beacon
 :recipe (:host github :repo "Malabarba/beacon")
)
#+end_src

#+begin_src emacs-lisp
(use-package! beacon
  :config
  (beacon-mode t)
  (setq beacon-push-mark 35
        beacon-blink-duration 0.5
        beacon-blink-delay 0.5
        beacon-blink-when-focused t
        beacon-color "deep sky blue")
    )
#+end_src

** dimmer
I want to differentiate the window I'm working with.

#+begin_src emacs-lisp :tangle packages.el
(package! dimmer
  :recipe (:host github :repo "gonewest818/dimmer.el"))
#+end_src

#+begin_src emacs-lisp
(dimmer-configure-which-key)
(dimmer-mode t)
(dimmer-configure-magit)
(dimmer-configure-org)

;; configure the dimmer
(setq dimmer-adjustment-mode :both)
(setq dimmer-fraction 0.3)
#+end_src

** Font size increase/decrease
Increase or decrease the font size
#+begin_src emacs-lisp
(global-set-key (kbd "M-+") 'text-scale-increase)
(global-set-key (kbd "M--") 'text-scale-decrease)
#+end_src
** Time and date
Put time and date on the status line
#+begin_src emacs-lisp
  (setq display-time-day-and-date t
        display-time-24hr-format t)
  (display-time)
#+end_src

* Navigation
** Uniquify
When several buffers visit identically-named files, Emacs must give the buffers distinct names. The usual method for making buffer names unique adds ‘<2>’, ‘<3>’, etc. to the end of the buffer names (all but one of them).

The forward naming method includes part of the file's directory name at the beginning of the buffer name
https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

** imenu-list
Better menus list

#+begin_src emacs-lisp :tangle packages.el
(package! imenu-list
  :recipe (:host github :repo "bmag/imenu-list"))
#+end_src

#+begin_src emacs-lisp
;; put the imenu in the position we want to
(setq imenu-list-position 'right)
;; Establish the depth of the entries shown
(setq org-imenu-depth 5)
(setq imenu-list-size 0.2)
;; map the keys
;; (global-unset-key (kbd "M-i"))
;;(global-set-key (kbd "C-c s I") #'imenu-list-smart-toggle)
;; Once you open imenu, focus on it
(setq imenu-list-focus-after-activation t)
;; configuring the keybinding as /la/ doom emacs
;; https://rameezkhan.me/posts/2020/2020-07-03--adding-keybindings-to-doom-emacs/
(map! :leader
      :desc "imenu toggle "
      "s I" #'imenu-list-smart-toggle)
#+end_src

** consult keybindings
#+begin_src emacs-lisp
(map! :after consult
      "C-s" #'consult-line
      "M-y" #'consult-yank-from-kill-ring
      "M-i" #'consult-imenu
      "M-g i" #'consult-imenu-multi
      "M-g h" #'consult-org-heading
      "M-g m" #'consult-mark
      "M-s f" #'consult-find
      "M-s r" #'consult-ripgrep
      )
#+end_src

** Keyboard chords
Shortcuts to commands using just quick key combinations.

#+begin_src emacs :tangle packages.el
(package! key-chord)
#+end_src

#+begin_src emacs-lisp
(use-package! key-chord
  :config
  (key-chord-mode 1)
  ;; Max time delay between two presses of the same key to be considered a key chord.
  ;; Should normally be a little longer than `key-chord-two-keys-delay'.
  (setq key-chord-two-keys-delay 0.1)
  (setq key-chord-one-key-delay 0.2) ; default 0.2
  (key-chord-define-global "ññ" 'eshell)
  (key-chord-define-global "kk" 'other-window)
  (key-chord-define-global "hh" 'ace-window)
  (key-chord-define-global "jj" 'avy-goto-char-2)
  (key-chord-define-global "jk" 'avy-goto-char-timer)
  (key-chord-define-global "jl" 'avy-goto-line)
  ;;(key-chord-define-global "zz" 'undo-tree-visualize)
  ;;(key-chord-define-global "ww" 'hydra-move/body)
  ;;(key-chord-define-global "yy" 'hydra-buffer-mgmt/body)
  )
#+end_src

** expand region
https://github.com/magnars/expand-region.el

#+begin_src emacs-lisp :tangle packages.el
(package! expand-region)
#+end_src

Select relevant regions incrementally.
#+begin_src emacs-lisp
(map!
      "C-ñ" #'er/expand-region)
#+end_src

* Orgmode
** some org configs for better behavior and usage
#+begin_src emacs-lisp
(use-package! org
  :config
  (setq
   ;; tag alignment
   ;; this value allows for modern themes and column fill to work well together.
   org-auto-align-tags t
   org-tags-column 0
   ;; org fold - edit in an invisible region
   org-fold-catch-invisible-edits 'show-and-error
   ;; C-a and C-e will move the cursor just the heading. No todo keyworks, no tags
   org-special-ctrl-a/e t
   ;; insert new heading after the current subtree
   org-insert-heading-respect-content t
   ))
#+end_src
** org-id
To create and use internal valid and unique links in org-mode, we will use the =org-id= features.
#+begin_src emacs-lisp
(use-package! org
  :config
  ;; org-id are globally unique UUIDs
  (setq org-id-method 'uuid)
  ;; It will use the CUSTOM_ID, if it exists
  ;;or will create a new one in the form or UUID, as seen above
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  ;; file to store the local =org-id= locations
  ;; This way is synced to all my computers
  (setq org-id-locations-file (expand-file-name "org-id-locations" my-data-dir)))
#+end_src
** Org is a variable pitch mode
Require the org mode.
#+begin_src emacs-lisp
(use-package! org
  :config
  (add-hook 'org-mode-hook 'variable-pitch-mode))
#+end_src

** Custom notes and timestamp
Put a note or a timestamp when something changes. For example:
- When the tasks is marked as DONE
- When the schedule or deadline date is changed

#+begin_src emacs-lisp
(use-package! org
  :config
  ;; Adds a timestamp to the state
  (setq org-log-done 'time)

  ;; Adds a custom note to the state
  (setq org-log-done 'note)

  ;; When the deadline or the schedule date is moved.
  ;; to keep track of how many times I have moved a task to the future.
  (setq org-log-redeadline (quote time))
  (setq org-log-reschedule (quote time)))
#+end_src

** Custom states for the tasks
These are the custom states for the tasks, and the character associated to it.

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-todo-keywords
        '(
          ;; Status for tasks
          (sequence "TODO(t)" "ONGOING(o)" "WAITING(w@/!)" "|" "DONE(d!)" "CANCELED(c@/!)")
          ;; Status for writing
          (sequence "TOWRITE(j)" "TOREVIEW(k@/!)" "REDO(l@/!)" "|" "FINISHED(ñ)" "PURGE(p@/!)")
          )
        )
  )
#+end_src

** org-clock
Remap the org-clock-in to a better key binding.
#+begin_src emacs-lisp
  (defun my/org-set-clock ()
    "One-off function for `org-mode' task clocking.

  Behaviour:
   ,* When there is no running clock, start
    the clock for the item at point.
   ,* When there is already a running clock and
    `point' is at the item which is being clocked
    stop the corresponding clock.
   ,* When there is already a running clock but `point'
    is not at the item which is being clocked,
    stop the clock and restart it for item at `point'."
    (interactive)
    (let ((interrupting (and (not org-clock-resolving-clocks-due-to-idleness)
                             (org-clocking-p))))
      (if interrupting
          (if (save-excursion
                (org-back-to-heading t)
                (and (equal (marker-buffer org-clock-hd-marker)
                            (current-buffer))
                     (= (marker-position org-clock-hd-marker)
                        (point))
                     (equal org-clock-current-task (nth 4 (org-heading-components)))))
              (org-clock-out)
            (org-clock-in))
        (org-clock-in))
      )
    )

  ;; keybindings
  (global-set-key (kbd "C-c C-x C-i") 'org-clock-in)
  (global-set-key (kbd "C-c C-x C-o") 'org-clock-out)
  (global-set-key (kbd "C-c C-x i") 'my/org-set-clock)
#+end_src

** org-habits
Enable org-habits.

#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-modules 'org-habit t))
#+end_src

** orgmode Agenda

All the agenda configs

*** Agenda files
We define the agenda files in this variable

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-agenda-files '(
                           ;; normal task files
                           "~/Nextcloud/agenda/tasks.org"
                           ;; added this one to be able to search in it, and add from here to the main task files.
  			   "~/Nextcloud/agenda/someday.org"
                           )
        )
  )
#+end_src

*** icons for the agenda categories
Have some fancy icons for the categories.
#+begin_src emacs-lisp
(use-package! org
  :config
  (customize-set-value
   'org-agenda-category-icon-alist
   `(
     ("calendar" "~/Nextcloud/config/icons/calendar.svg" nil nil :ascent center :mask heuristic)
     ("tasks" "~/Nextcloud/config/icons/check-square.svg" nil nil :ascent center :mask heuristic)
     ("projects" "~/Nextcloud/config/icons/list.svg" nil nil :ascent center :mask heuristic)
     ("financial" "~/Nextcloud/config/icons/dollar-sign.svg" nil nil :ascent center :mask heuristic)
     ("birthdays" "~/Nextcloud/config/icons/heart.svg" nil nil :ascent center :mask heuristic)
     ("revision" "~/Nextcloud/config/icons/shuffle.svg" nil nil :ascent center :mask heuristic)
     ("habits" "~/Nextcloud/config/icons/refresh-ccw.svg" nil nil :ascent center :mask heuristic)
     ("care" "~/Nextcloud/config/icons/heart.svg" nil nil :ascent center :mask heuristic)
     )
   )
  )
#+end_src

*** Get rid of the DONE tasks in the agenda view
We dont want the cluttering in our views. If a task is done, don't show it on the agenda view.

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-timestamp-if-done t)
  )
#+end_src

*** TODO Custom agenda commands
We define some agenda custom commands, to refine views, and get a clearer undestanding of the tasks.

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-agenda-custom-commands
       '(
         ;;;;;;;;;;;;;;;;;;;;;;;;;;;
         ; Custom agenda commands
         ;;;;;;;;;;;;;;;;;;;;;;;;;;;
         ("c" . "My Custom Agendas")

         ;; All the unescheduled tasks
          ("cu" "Unscheduled TODO"
            ((tags-todo "-backlog"
                  ((org-agenda-overriding-header "\nUnscheduled TODO")
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp)))))
              nil
           nil)

          ;; All the HIGH priority tasks, no backlog
           ("ch" "high priority tasks"
             (
               (tags-todo "+PRIORITY=\"A\"-backlog"
                  (
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                   (org-agenda-overriding-header "High-priority unfinished tasks:")
                   )

                  )

               )
             )

           ;; All tasks, sorted and grouped
           ("ct" "all tasks, sorted"
             (
              ;; High priority tasks, no backlog
              (
               tags-todo "+PRIORITY=\"A\"-backlog"
                  (
                    (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                    (org-agenda-overriding-header "High-priority unfinished tasks:")
                    (org-agenda-prefix-format " %10c %5e ")

                    )
                  )
              ;; Ongoing tasks that needs effort from my side
              (tags-todo "-backlog-books/ONGOING"
                (
                 (org-agenda-overriding-header "Ongoing tasks:")
                 (org-agenda-prefix-format " %10c %5e ")
                 )
                )

              ;; Tasks scheduled today
              (agenda ""
                   (
                    (org-agenda-time-grid nil)
                    (org-schedule-warning-days 1)        ;; [1]
                    (org-agenda-entry-types '(:scheduled))  ;; [2]
                    (org-agenda-overriding-header "Scheduled today tasks:")
                    (org-agenda-prefix-format " %10c %5e ")
                    )
                   )

              ;; Tasks that are waiting on something
              (tags-todo "-backlog-books/WAITING"
                (
                 (org-agenda-overriding-header "Waiting tasks:")
                 (org-agenda-prefix-format " %10c %5e ")
                 )
                )

              ;; Tasks still not started, that are not high priority
              (tags-todo "-backlog-books-calendar +PRIORITY={B\\|C}/TODO"
                (
                 (org-agenda-overriding-header "TODO tasks:")
                 (org-agenda-prefix-format " %10c %5e ")
                 )
                )

              ;; Calendar tasks
              (tags-todo "calendar"
                (
                 (org-agenda-overriding-header "Calendar tasks:")
                 (org-agenda-prefix-format " %10c %5e ")
                 )
                )

              ;; Stuck tasks and projects
              (stuck ""
                (
                 (org-agenda-overriding-header "Stuck tasks:")
                 (org-agenda-prefix-format " %10c %5e ")
                 )
                )

              ;; end configuration all tasks sorted and grouped
              )
             )

           ;;;;;;;;;;;;
           ;; Time based queries
           ;;;;;;;;;;;;
           ;; 'In a day' tasks
           ("d" "Today"
             (
              (agenda "" ((org-agenda-span 1)
                          (org-agenda-sorting-strategy
                           (quote ((agenda time-up priority-down tag-up) ))
                           )
                           ; this will show tasks with a deadline of 2 days more
                          (org-deadline-warning-days 2)


                          )
                      )
              )
             )

           ; 'In a week' tasks
           ("w" "Week ahead"
              (
               (agenda "" ((org-agenda-span 7)
                           (org-agenda-sorting-strategy
                            (quote ((agenda time-up priority-down tag-up) ))
                            )
                           (org-deadline-warning-days 0)
                           )
                       )
               )
              )

           ;;;;;;;;;;;;;;;;;;;;;;;
           ;; Location/context based queries
           ;;;;;;;;;;;;;;;;;;;;;;;

           ; only shows home tagged entries
           ("h" "At home" tags-todo "+home-backlog"
             (
               (org-agenda-overriding-header "Home")
             )
           )

           ; only shows outside tagged entries
           ("o" "Outside tasks" tags-todo "+outside-backlog"
             (
               (org-agenda-overriding-header "Outside")
             )
           )

           ;;;;;;;;;;;;;;;;
           ; backlog entries
           ("b" "Backlog entries" tags-todo "+backlog-objetivos-calendar"
             (
               (org-agenda-overriding-header "Backlog")
             )
           )

       )
  )
)
#+end_src

*** Show next 7 days in the agenda view
I need a more clear view for things to come. We can see 15 days from now.
#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-agenda-span 'week)
  (setq org-agenda-start-on-weekday nil)
  )
#+end_src

*** Show the agenda in another window
I want to see the agenda side by side of the files I'm working with.
#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-agenda-window-setup 'reorganize-frame))
#+end_src

*** Refile entries
This lets you choose refiling targets in heading depth of 9, and lets you get also the files in the same directory hierarchy.

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-refile-targets '(
                             (nil :maxlevel . 9)
                             (org-agenda-files :maxlevel . 9)
                             ("referencias.org" :maxlevel . 9)
                             ("maybe.org" :maxlevel . 9)
                             ("books.org" :maxlevel . 9)
                             ("~/Nextcloud/escritura/retazos/ideas.org" :maxlevel . 9)
                             )
        )
  ;; Refile in a single go
  (setq org-outline-path-complete-in-steps nil)
  ;; Show full paths for refiling
  (setq org-refile-use-outline-path t)
  )
#+end_src

*** Remove the "validate" link from html exports
#+begin_src emacs-lisp
(use-package! org
  :config
  ;; don't show the "validate" link on org-html exports
  (setq org-html-validation-link nil)
  )
#+end_src

*** Ignore exporting some headlines (just the headlines)
This allows headlines to be ignored in the exports. To do so, the ignore tag (C-c C-c ignore) has to be in the header to be ignored. *We only ignore the headlines, the content is still shown.*

#+begin_src emacs-lisp
(use-package! org
  :config
  (load "~/Nextcloud/config/.emacs.d/vendor/ox-extra/ox-extra.el")
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines))
  )
#+end_src

*** Export to Latex
All the latex exports

**** TODO Memoir class for org2latex (complete these options)
memoir is a class used to create beautiful documents.

#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("memoir"
                 "\\documentclass[a4paper,17pt,openright,twoside]{memoir}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \% Para poner notas en los márgenes
  \\usepackage{todonotes}

  \% Para tachar palabras
  \\usepackage[normalem]{ulem}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  % command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}

  % Chapter style
   \\chapterstyle{dash}

  % How the page is formatted
    \\pagestyle{Ruled}



                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section*{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** TODO Memoir_draft class for org2latex (complete these options)
memoir is a class used to create beautiful documents.

#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("memoir_draft"
                 "\\documentclass[a4paper,17pt,draft,openright,twoside]{memoir}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \% Para poner notas en los márgenes
  \\usepackage{todonotes}

  \% Para tachar palabras
  \\usepackage[normalem]{ulem}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  \% command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}

  \% Chapter style
  \\chapterstyle{dash}

  \% How the page is formatted
  \\pagestyle{Ruled}





                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection*{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection*{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph*{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph*{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** TODO Memoir_chapter class for org2latex (complete these options)
Same as memoir class, but it start just with chapters, no "part"

#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("memoir_chapter"
                 "\\documentclass[a4paper,17pt,openright,twoside]{memoir}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  % Chapter style
   \\chapterstyle{dash}

  % How the page is formatted
    \\pagestyle{Ruled}



                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"

                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section*{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** TODO Memoir_chapter_draft class for org2latex (complete these options)
Same as memoir class, but it start just with chapters, no "part"

#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("memoir_chapter_draft"
                 "\\documentclass[a4paper,17pt,draft,openright,twoside]{memoir}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \% Para poner notas en los márgenes
  \\usepackage{todonotes}

  \% Para tachar palabras
  \\usepackage[normalem]{ulem}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  \% command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}

  \% Chapter style
  \\chapterstyle{dash}

  \% How the page is formatted
  \\pagestyle{Ruled}





                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"

                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection*{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection*{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph*{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph*{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** TODO reporting class for org2latex (complete these options)


#+begin_src emacs-lisp
(use-package! org
  :config
  (add-to-list 'org-latex-classes
       '("reporting"
                 "\\documentclass[a4paper,17pt,openright,twoside]{article}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \% Para poner notas en los márgenes
  \\usepackage{todonotes}

  \% Para tachar palabras
  \\usepackage[normalem]{ulem}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  \% command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}




                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section*{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
               )
)
#+end_src

**** Smart quotes
Add smart quotes for latex

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-export-with-smart-quotes t)
  )
#+end_src

** TODO Capture templates
Here I will add template captures for doing several things:

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-capture-templates'(
                               ("t" "My TODO task format." entry
                                (file+headline "~/Nextcloud/agenda/tasks.org" "Tasks")
                                "** TODO %i%? \n:LOGBOOK: \n:CREATED: %U \n:END:"
                                :empty-lines-after 1)

                               ("p" "New project." entry
                                (file+headline "~/Nextcloud/agenda/tasks.org" "Projects")
                                "** TODO %? \n:LOGBOOK: \n:CREATED: %U \n:END:\n  :PROPERTIES:\n:COOKIE_DATA: todo recursive\n:END:\n   - Objetivo:"
                                :empty-lines-after 1)

                               ;; Writing related things
		               ;; Everything that I find interesting to create, no matter what it is
	                       ("h" "Compost heap" item
                                (file+headline "~/Nextcloud/escritura/retazos/compost_heap.org" "Compost heap")
                                "%i"
                                :empty-lines-after 1)

		               ;; A possible writing idea
                               ("w" "Writing idea." entry
                                (file+headline "~/Nextcloud/escritura/retazos/ideas.org" "Ideas")
                                "** TODO %?\n*** Personajes\n- \n*** Ambientación\n*** Eventos\n"
                                :empty-lines-after 1)

                               ;; An interesenting character
                               ("P" "Personaje" entry
                                (file "~/Nextcloud/escritura/ideas/personajes.org")
                                "* %i%?"
                                :empty-lines-after 1)
                               )
        )
  )
#+end_src

** Capture to this buffer
https://github.com/ballantony/emacs-writing/blob/main/DoomEmacsWriting.org

Used to capture notes in this file. Useful to maintain notes and snippets separated by projects. I will use this for my writing projects.
#+begin_src emacs-lisp
  (defun my/capture-to-this-buffer ()
    "Capture note to this buffer"
    (interactive)
    (cond  ((not  (eq major-mode 'org-mode))
            (message "Can't capture to non org-mode buffer"))
           (t
            (let* ((this-file buffer-file-name)
                   (org-capture-templates
                    `(("t" "Todo" entry (file+headline ,this-file "Notes")
                       "** TODO %?"))))
              (org-capture)))))
  (global-set-key (kbd "C-c C") 'my/capture-to-this-buffer)
#+end_src

** Remove the markup indicators
No need to see the markup indicators when writing.

#+begin_src emacs-lisp
(use-package! org
  :config
  (setq org-hide-emphasis-markers t)
)
#+end_src

** org-appear
/Hides/ the *emphasis* marks +of+ from orgmode, until you are on them.
#+begin_src emacs-lisp :tangle packages.el
(package! org-appear
  :recipe (:host github
           :repo "awth13/org-appear"))
#+end_src

#+begin_src emacs-lisp
  (use-package org-appear
    :hook (org-mode . org-appear-mode)
    )
#+end_src

** org-roam
Org-roam related config.

#+begin_src emacs-lisp
(use-package! org-roam
  :config
  (setq org-roam-v2-ack t)
  (setq org-roam-directory (file-truename "~/Nextcloud/personal/roam"))

  ;; ("C-c n l" . org-roam-buffer-toggle)
  ;; ("C-c n f" . org-roam-node-find)
  ;; ("C-c n i" . org-roam-node-insert)
  ;; ("C-c n c" . org-roam-capture)
  ;; :map org-roam-dailies-map
  ;; ("Y" . org-roam-dailies-capture-yesterday)
  ;; ("T" . org-roam-dailies-capture-tomorrow)
  ;; :bind-keymap
  ;; ("C-c n d" . org-roam-dailies-map)

  ;; provide org-roam completion links outside org files.
  (setq org-roam-completion-everywhere t)
  ;; Location of the roam database
  (setq org-roam-db-location (file-truename "~/Nextcloud/personal/roam/org-roam.db"))
  ;; Ensure the keymap is available
  ;;(require 'org-roam-dailies)
  ;; org-roam export: https://www.orgroam.com/manual.html#org_002droam_002dexport
  ;;      (require 'org-roam-export)
  ;; autosync
  (org-roam-db-autosync-mode 1)
  )
#+end_src

*** org-roam templates
#+begin_src emacs-lisp
(setq org-roam-capture-templates
      '(
        ;; default template
        ("d" "default" plain
         "* TODO ${title}\n%?"
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
         :unnarrowed t)
        ("b" "book notes" plain (file "~/.doom.d/roamtemplates/BookNoteTemplate.org")
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: book")
         :unnarrowed t)
        ("w" "writing idea" plain (file "~/.doom.d/roamtemplates/WritingIdea.org")
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: writing")
         :unnarrowed t)
        ("c" "writing character" plain (file "~/.doom.d/roamtemplates/CharacterIdea.org")
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: writing character")
         :unnarrowed t)
        )
      )
#+end_src

*** Search by title and tags
To search by title and tags, we will use the information contained here:

https://github.com/org-roam/org-roam/pull/2054
#+begin_src emacs-lisp
(use-package! org-roam
  :config
  (setq org-roam-node-display-template
        (concat "${title:*} "
                (propertize "${tags:20}" 'face 'org-tag)))
  )
#+end_src

*** Search using content or roam using ripgrep
This does full text search on my roam notes.

#+begin_src emacs-lisp
(use-package! org-roam
  :config
  (defun my/org-roam-rg-search ()
    "Search org-roam directory using consult-ripgrep. With live-preview."
    ((insert )nteractive)
    (let ((consult-ripgrep-command "rg --null --ignore-case --type org --line-buffered --color=always --max-columns=500 --no-heading --line-number . -e ARG OPTS"))
      (consult-ripgrep org-roam-directory)))
  (global-set-key (kbd "C-c rr") 'my/org-roam-rg-search)
  )
#+end_src

*** Dailies config
#+begin_src emacs-lisp
(use-package! org-roam
  :config
  ;; Daily notes for org-roam
  ;; Directory is relative to org-roam-directory
  (setq org-roam-dailies-directory "daily/")

  ;; Capture template for the dailies
  (setq org-roam-dailies-capture-templates
        '(("d" "default" entry
           "* %?"
           :if-new (file+head "%<%Y-%m-%d>.org"
                              "#+title: %<%Y-%m-%d>\n#+filetags: daily\n"))))
  )
#+end_src

*** org-roam-ui
Load org-roam UI and all its dependencies.

#+begin_src emacs-lisp :tangle packages.el
(package! org-roam-ui
  :recipe (:host github :repo "org-roam/org-roam-ui")
  )
#+end_src

#+begin_src emacs-lisp
(use-package! org-roam
  :config
  (use-package! org-roam-ui
    ;;:after org-roam
    :hook (org-roam . org-roam-ui-mode)
    )
  )
#+end_src

*** org-roam TODOs to the agenda
I want to get all my org-roam TODOs in the agenda view, but I need to do it only with the files that contain the TODO keywords, and not the whole org-roam directory.

TODO: I need to activate this only for my personal profile, and not my work profile

https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html

#+begin_src emacs-lisp
(use-package! org-roam
  :config

  ;; Load this only on my personal profile, and not in my work one
  (if my-homeenvironment-p
      (progn



        ;; we want to load these functions if org-roam is present
        (if (not(require 'org-roam nil t))
            ;; if condition
            (message "org-roam not found")
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ;; else condition

          (setq my/roamtag "roamtag")

          (defun vulpea-buffer-prop-set (name value)
            "Set a file property called NAME to VALUE in buffer file.
          If the property is already set, replace its value."
            (setq name (downcase name))
            (org-with-point-at 1
              (let ((case-fold-search t))
                (if (re-search-forward (concat "^#\\+" name ":\\(.*\\)")
                                       (point-max) t)
                    (replace-match (concat "#+" name ": " value) 'fixedcase)
                  (while (and (not (eobp))
                              (looking-at "^[#:]"))
                    (if (save-excursion (end-of-line) (eobp))
                        (progn
                          (end-of-line)
                          (insert "\n"))
                      (forward-line)
                      (beginning-of-line)))
                  (insert "#+" name ": " value "\n")))))

          (defun vulpea-buffer-prop-set-list (name values &optional separators)
            "Set a file property called NAME to VALUES in current buffer.
          VALUES are quoted and combined into single string using
          `combine-and-quote-strings'.
          If SEPARATORS is non-nil, it should be a regular expression
          matching text that separates, but is not part of, the substrings.
          If nil it defaults to `split-string-default-separators', normally
          \"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t.
          If the property is already set, replace its value."
            (vulpea-buffer-prop-set
             name (combine-and-quote-strings values separators)))

          (defun vulpea-buffer-tags-set (&rest tags)
            "Set TAGS in current buffer.
            If filetags value is already set, replace it."
            (vulpea-buffer-prop-set "filetags" (string-join tags " ")))

          (defun vulpea-buffer-prop-get (name)
            "Get a buffer property called NAME as a string."
            (org-with-point-at 1
              (when (re-search-forward (concat "^#\\+" name ": \\(.*\\)")
                                       (point-max) t)
                (buffer-substring-no-properties
                 (match-beginning 1)
                 (match-end 1)))))


          (defun vulpea-buffer-prop-get-list (name &optional separators)
            "Get a buffer property NAME as a list using SEPARATORS.
              If SEPARATORS is non-nil, it should be a regular expression
              matching text that separates, but is not part of, the substrings.
              If nil it defaults to `split-string-default-separators', normally
              \"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t."
            (let ((value (vulpea-buffer-prop-get name)))
              (when (and value (not (string-empty-p value)))
                (split-string-and-unquote value separators))))

          (defun vulpea-buffer-tags-get ()
            "Return filetags value in current buffer."
            (vulpea-buffer-prop-get-list "filetags" " "))

          (defun vulpea-buffer-tags-add (tag)
            "Add a TAG to filetags in current buffer."
            (let* ((tags (vulpea-buffer-tags-get))
                   (tags (append tags (list tag))))
              (apply #'vulpea-buffer-tags-set tags)))



          (defun vulpea-project-p ()
            "Return non-nil if current buffer has any todo entry.

                  TODO entries marked as done are ignored, meaning the this
                  function returns nil if current buffer contains only completed
                  tasks."
            (seq-find                                 ; (3)
             (lambda (type)
               (eq type 'todo))
             (org-element-map                         ; (2)
                 (org-element-parse-buffer 'headline) ; (1)
                 'headline
               (lambda (h)
                 (org-element-property :todo-type h)))))

          (defun vulpea-project-update-tag ()
            "Update PROJECT tag in the current buffer."
            (when (and (not (active-minibuffer-window))
                       (vulpea-buffer-p))
              (save-excursion
                (goto-char (point-min))
                (let* ((tags (vulpea-buffer-tags-get))
                       (original-tags tags))
                  (if (vulpea-project-p)
                      (setq tags (cons "roamtag" tags))
                    (setq tags (remove "roamtag" tags)))

                  ;; cleanup duplicates
                  (setq tags (seq-uniq tags))

                  ;; update tags if changed
                  (when (or (seq-difference tags original-tags)
                            (seq-difference original-tags tags))
                    (apply #'vulpea-buffer-tags-set tags))))))

          (defun vulpea-buffer-p ()
            "Return non-nil if the currently visited buffer is a note."
            (and buffer-file-name
                 (string-prefix-p
                  (expand-file-name (file-name-as-directory org-roam-directory))
                  (file-name-directory buffer-file-name))))

          (defun vulpea-project-files ()
            "Return a list of note files containing 'roamtag' tag." ;
            (seq-uniq
             (seq-map
              #'car
              (org-roam-db-query
               [:select [nodes:file]
                :from tags
                :left-join nodes
                :on (= tags:node-id nodes:id)
                :where (like tag (quote "%\"roamtag\"%"))]))))

          ;; This will overwrite the current agenda files, and we don't want that
          (defun vulpea-agenda-files-update (&rest _)
            "Update the value of `org-agenda-files'."
            (setq org-agenda-files (vulpea-project-files)))

          (defun inject-vulpea-project-files (org-agenda-files)
            (append org-agenda-files (vulpea-project-files)))
          (advice-add 'org-agenda-files :filter-return #'inject-vulpea-project-files)

          (add-hook 'find-file-hook #'vulpea-project-update-tag)
          (add-hook 'before-save-hook #'vulpea-project-update-tag)

          ;; original code that overwrites the agenda files
          ;;  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
          ;;  (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)
          )
        ))
  )
#+end_src

** Completion notes in to the Logbook
#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
#+end_src

** Custom notes and timestamp
Put a note or a timestamp when something changes. For example:
- When the tasks is marked as DONE
- When the schedule or deadline date is changed

#+begin_src emacs-lisp
  ;; Adds a timestamp to the state
  ;;(setq org-log-done 'time)
    (setq org-log-done nil)

  ;; Adds a custom note to the state
  ;;(setq org-log-done 'note)

  ;; When the deadline or the schedule date is moved.
  ;; to keep track of how many times I have moved a task to the future.
  (setq org-log-redeadline (quote time))
  (setq org-log-reschedule (quote time))
#+end_src

** TODO org custom tags

The org tags are organized by location, tools, and activities.

#+begin_src emacs-lips
  (setq org-tag-alist '(
                        ;; Contexts based on locations
                        ("@work" . ?W) ("@home" . ?h)  ("@outside" . ?o)
                        ;; Contexts based on tools
                        ("computer" . ?c) ("mobile" . ?m)  ("penpaper" . ?p)
                        ;; Contexts based on activities
                        ("emacs" . ?e) ("writing" . ?w) ("reading" . ?r) ("personal" . ?p) ("calls" . ?C)
                        )
        )
#+end_src

** TODO org tags justified
#+begin_src emacs-lisp
(setq org-tags-column 0)
#+end_src

** TODO org-modern
We put some fancy visual effects on org-mode.

#+begin_src emacs-lisp :tangle packages.el
(package! org-modern)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-modern
  :after org
  :hook (org-mode . org-modern-mode)
  :config
  (setq org-modern-star nil        ;; we keep the stars instead the triangles
        org-modern-priority nil    ;; keep the priority
        org-modern-table nil       ;; the tables get garbled
        )
  (org-modern-mode 1)
  )
#+end_src

* Writing
** org-journal
This is for journaling every day, if possible.
Documentation can be found here:

https://github.com/bastibe/org-journal

#+begin_src emacs-lisp
;;("C-c r ñ" . org-journal-new-entry)
(use-package! org-journal
  :config
  (setq org-journal-date-prefix "#+TITLE: ")
  (setq org-journal-file-format "%Y-%m-%d.org")
  ;;(setq org-journal-dir "~/Nextcloud/personal/diario/")
  (setq org-journal-dir (expand-file-name "personal/diario" my-clear-directory))
  (setq org-journal-date-format "%A, %d %B %Y")
  (setq org-journal-encrypt-journal nil)
  )
#+end_src

** Buscar en la RAE
Seach a word in the spanish dictionary.

#+begin_src emacs-lisp
(defun my/buscarae (palabra)
  "Busca una palabra en la RAE."
  (interactive "s¿Qué palabra quieres buscar? ")
  (eww (concat "https://dle.rae.es/" palabra))
  )
#+end_src

** Buscar sinónimos
Seach a synonim.

#+begin_src emacs-lisp
(defun my/sinonimo (palabra)
  "Busca una palabra en un diccionario de sinónimos"
  (interactive "s¿Qué palabra quieres buscar? ")
  (eww (concat "https://www.wordreference.com/sinonimos/" palabra))
  )
#+end_src

** Translate from english
Translate a word

#+begin_src emacs-lisp
(defun my/translate (palabra)
  "Traduccion de inglés a español"
  (interactive "s¿Qué palabra quieres buscar? ")
  (eww (concat "https://www.deepl.com/translator#en/es/" palabra))
  )
#+end_src

** Create a story file on the fly
Sometimes I want to create

#+begin_src emacs-lisp
(defvar my/stories-directory "~/Nextcloud/escritura/historias/ejercicios"
  "Directory where org files created by `my/create-org-file' will be stored.")

(defun my/create-empty-writing-file (text)
  "Create a new org file with name format `%Y%m%d-<text>.org', where <text> is the `text' argument with spaces replaced by underscores. The file will be stored in `my/stories-directory'."
  (interactive "sEnter file name: ")
  (let* ((date (format-time-string "%Y%m%d"))
         (filename (concat date "-" (replace-regexp-in-string " " "_" text) ".org"))
         (full-path (concat my/stories-directory "/" filename)))
    (find-file full-path)))

(defun my/create-writing-exercise (text)
  "Create a new file with the current date and the specified TEXT.
The file is saved in the directory specified by `my/stories-directory'.
The file name format is \"%Y%m%d-<text>.org\", with spaces in TEXT replaced by \"_\".
The function runs a Python script that generates a writing prompt
and stores the output in the file."
  (interactive "sEnter file name: ")
  (let* ((date (format-time-string "%Y%m%d"))
         (file-name (concat date "-" (replace-regexp-in-string " " "_" text) ".org"))
         (file-path (concat my/stories-directory "/" file-name))
         (python-output (shell-command-to-string "python  ~/Nextcloud/escritura/software/writing_companion/writing_companion.py -s all prompt")))
    (with-temp-file file-path
      (insert "#+TITLE: " text "\n\n" python-output))
    (find-file file-path)
    ))
#+end_src

* Programming


** display-fill-column-indicator-mode
Show the end of the line limit for the programming modes.

#+begin_src emacs-lisp :tangle yes
(add-hook 'prog-mode-hook 'display-fill-column-indicator-mode)
#+end_src

* Testing
** projectile file
Store my personal projects in the sync directory.

#+begin_src emacs-lisp
;; Load this only when it is my home environment
(if (not my-workenvironment-p)
    (setq projectile-known-projects-file "~/Nextcloud/config/.emacs.d/projectile.projects")
    )
#+end_src

** org-remark
Annotate any file in an accesory file.
https://github.com/nobiot/org-remark
https://nobiot.github.io/org-remark/

#+begin_src emacs-lisp :tangle packages.el
(package! org-remark
  :recipe (:host github :repo "nobiot/org-remark"))
#+end_src

#+begin_src emacs-lisp
(use-package! org
  :config
  (require 'org-remark)
  (require 'org-remark-global-tracking)
  (org-remark-global-tracking-mode +1)


  ;; Create a file of notes for each file, with the buffer name
  (defun my/org-remark-file-name ()
    (concat (file-name-base (org-remark-notes-file-name-function))
            ".org"))

  (setq org-remark-notes-file-name
        #'my/org-remark-file-name)

  ;; Create highlighter pens for different parts
  ;; Since I use alternate dark and clear themes, these must be useful for both
  (org-remark-create "blue"
                     '(:underline "sky blue" :background "deep sky blue")
                     '(CATEGORY "editing"))

  ;; can be properly seen in both dark and clear themes
  (org-remark-create "dark-blue-line"
                     '(:underline "deep sky blue")
                     '(CATEGORY "editing"))

  (org-remark-create "boring-gray"
                     '(:background "dim gray"))

  (org-remark-create "salmon"
                     '(:background "salmon"))

  (org-remark-create "royal-blue"
                     '(:background "royal blue"))

  ;; Key-bind `org-remark-mark' to global-map so that you can call it
  ;; globally before the library is loaded.
  (define-key global-map (kbd "C-c m m") #'org-remark-mark)
  (define-key global-map (kbd "C-c m o") #'org-remark-open)
  (define-key global-map (kbd "C-c m n") #'org-remark-view-next)
  (define-key global-map (kbd "C-c m p") #'org-remark-view-prev)
  (define-key global-map (kbd "C-c m r") #'org-remark-remove)
  (define-key global-map (kbd "C-c m j") #'org-remark-change)
  (define-key global-map (kbd "C-c m b") #'org-remark-mark-blue)

  ;; The remark file will be named based on the original file
  )
#+end_src

** TODO elfeed and elfeed-org
Configuration for the elfeed and the org files.
#+begin_src emacs-lisp
;; database for elfeed
(use-package! elfeed
  :config
  (elfeed-org)
  (setq elfeed-db-directory (expand-file-name "elfeed/db/" my-data-dir))

  ;; Optionally specify a number of files containing elfeed
  ;; configuration. If not set then the location below is used.
  ;; Note: The customize interface is also supported.
  (setq rmh-elfeed-org-files (list "~/Nextcloud/config/.emacs.d/elfeed/elfeed.org"))
  ;; put the filter to 1 month ago by default
  (setq elfeed-search-set-filter "@1-month-ago")

  ;; open elfeed and update it
  (defun my/elfeed()
    "Opens elfeed and updates it in just a go."
    (interactive)
    (elfeed)
    (elfeed-update)
    )

  (map! :leader
        :desc "elfeed refresh and UI"
        "d f" #'my/elfeed)

  )
#+end_src

** TODO Mastodon
https://github.com/emacsmirror/mastodon

I can now check mastodon from emacs.
Only evaluated if in my home environment, my encrypted directory is mounted, as the auth information is stored there.

#+begin_src emacs-lisp :tangle packages.el
(package! mastodon)
#+end_src

#+begin_src emacs-lisp
(if (and my-clear-directory-is-mounted-p my-homeenvironment-p)
    (progn
      (setq mastodon-instance-url "https://mastodon.online"
  	    mastodon-active-user "jcastp")
      ;; my auth information is now in my encrypted directory
      (setq mastodon-client--token-file (expand-file-name "personal/emacs/mastodon.plstore" my-clear-directory))
      ;; Create a keybinding to mastodon
      (map! :leader
            :desc "Mastodon"
            "d m" #'mastodon)
      )
  )
#+end_src

** Nov.el
Read e-pub in emacs.

https://tech.toryanderson.com/2022/11/23/viewing-epub-in-emacs/

#+begin_src emacs-lisp :tangle packages.el
  (package! esxml
    :recipe (:host github :repo "tali713/esxml"))

   (package! nov
     :recipe (:host nil :repo "https://depp.brause.cc/nov.el.git"))
#+end_src


#+begin_src emacs-lisp
(use-package! nov
     :config
     (setq nov-text-width 100)
     ;;(setq nov-text-width t)
     (setq visual-fill-column-center-text t)
     (add-hook 'nov-mode-hook 'visual-line-mode)
     (add-hook 'nov-mode-hook 'visual-fill-column-mode)
     ;; We save the place we left the e-pub in this file:
     (setq nov-save-place-file (expand-file-name "nov-places" my-data-dir))
    (defun my/nov-font-setup ()
      (face-remap-add-relative 'variable-pitch :family "Gentium"
                                :height 1.2))
     (add-hook 'nov-mode-hook 'my/nov-font-setup)
     (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
     )
#+end_src

** calibre
https://github.com/chenyanming/calibredb.el

#+begin_src emacs-lisp :tangle packages.el
(package! calibredb)
#+end_src

#+begin_src emacs-lisp
;; load this only on my home env
(if (and
     my-homeenvironment-p
     ;; the calibre library ddbb exists
     (file-exists-p "/home/calibre_libros/metadata.db"))
    (progn
      ;; here comes the actions I want to be done at a home environment
      (use-package! calibredb
        :config
        (setq calibredb-root-dir "/home/calibre_libros/")
        (setq calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir))
        (setq calibredb-library-alist '(("/home/calibre_libros/")
                                        ))
        (setq calibredb-size-show t)
        (setq calibredb-id-width 10)
        )))
#+end_src

** reading list
Here I will configure my personal method for a reading list.
I used org-books, but the package seems to not be maintained, and the URL fetching seems to be broken, so I will rely on my own personal list.

#+begin_src emacs-lisp
  ;; where my book list will be stored
  (defvar my-booklist-file (expand-file-name "Nextcloud/agenda/books.org" (getenv "HOME")))
#+end_src

#+begin_src emacs-lisp
  (add-to-list 'org-capture-templates
  	     '(
  	       ;; books to read
  	       "b"
  	       "Manual book entry"
  	       entry
  	       (file+headline "~/Nextcloud/agenda/books.org" "inbox")
  	       "** %^{TITLE}\n:PROPERTIES:\n:ADDED: %<[%Y-%02m-%02d]>\n:END:%^{AUTHOR}p\n%?"
  	       :empty-lines 1
  	       )
  	     ;; append at the end of the capture list
  	     t
  	     )

#+end_src

** TODO hammy - time intervals
https://github.com/alphapapa/hammy.el
Time intervals, such as pomodoro.

#+begin_src emacs-lisp :tangle packages.el
(package! hammy)
#+end_src

#+begin_src emacs-lisp
(use-package! hammy
  :config
  (hammy-mode)
  ;; We name the timer with the Unicode TOMATO character, and propertize
  ;; it with a tomato-colored face.
  (hammy-define (propertize "🍅" 'face '(:foreground "tomato"))
                :documentation "The classic pomodoro timer."
                :intervals
                (list
                 (interval :name "Work"
                           :duration "25 minutes"
                           :before (do (announce "Starting work time.")
                                       (notify "Starting work time."))
                           :advance (do (announce "Break time!")
                                        (notify "Break time!")))
                 (interval :name "Break"
                           :duration (do (if (and (not (zerop cycles))
                                                  (zerop (mod cycles 3)))
  				             ;; If a multiple of three cycles have
  				             ;; elapsed, the fourth work period was
  				             ;; just completed, so take a longer break.
  				             "30 minutes"
                                           "5 minutes"))
                           :before (do (announce "Starting break time.")
                                       (notify "Starting break time."))
                           :advance (do (announce "Break time is over!")
                                        (notify "Break time is over!")))))
  )
#+end_src

** TODO Remove visual-fill-mode in org-agenda-mode
I just want the org-agenda lines to be just on one line, so I remove the visual-fill-mode from all the agenda views.

#+begin_src emacs-lisp :tangle yes
(defun my/org-agenda-format ()
  "Set some special configs for org-agenda mode."
  (visual-line-fill-column-mode 0)
  )
(add-hook 'org-agenda-mode-hook 'my/org-agenda-format)
#+end_src

** TODO ellama
#+begin_src emacs-lisp :tangle packages.el
(package! ellama
  :recipe (:host github :repo "s-kostyaev/ellama"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! ellama
  :init
  :config
  ;; setup key bindings
  (setopt ellama-keymap-prefix "C-c d e")
  (require 'llm-ollama)
  ;; initial model
  (setopt ellama-provider
          (make-llm-ollama
           :chat-model "phi3:medium"
           :embedding-model "phi3:medium"))
  (setopt ellama-providers
          '(
             ("phi3:medium" . (make-llm-ollama
                               :chat-model "phi3:medium"
                               :embedding-model "phi3:medium"))
             ("deepseek-coder-v2:16b" . (make-llm-ollama
                                         :chat-model "deepseek-coder-v2:16b"
                                         :embedding-model "deepseek-coder-v2:16b"))
             ("gemma2:27b" . (make-llm-ollama
                              :chat-model "gemma2:27b"
                              :embedding-model "gemma2:27b"))
             ("dolphin-mixtral" . (make-llm-ollama
                                   :chat-model "dolphin-mixtral"
                                   :embedding-model "dolphin-mixtral"))
             ("llama3" . (make-llm-ollama
	                  :chat-model "llama3"
	                  :embedding-model "llama3"))
	    )
          )
  )
#+end_src

** TODO ready-player mode
#+begin_src emacs-lisp :tangle packages.el
(package! ready-player
   :recipe (:host github :repo "xenodium/ready-player"))
#+end_src
#+begin_src emacs-lisp
  (use-package! ready-player
    :config
    (ready-player-mode)
    (setq ready-player-repeat t))
#+end_src


** TODO guess-language
Since I work in two languages, I need a method to change the dictionary. It will be better if it can be done automatically.

#+begin_src emacs-lisp :tangle packages.el
(package! guess-language)
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package guess-language
  :config
  (setq guess-language-languages '(en es))
  (setq guess-language-min-paragraph-length 80)
  ;; define the dicts I want to use for my languages
  (setq guess-language-langcodes
  	'((en . ("en_US" "English"))
  	  (es . ("es_ES" "Spanish"))))
  (guess-language-mode)
  ;; activate the mode when I go to text files
  (add-hook 'text-mode-hook (lambda () (guess-language-mode 1)))
  (add-hook 'org-mode-hook (lambda () (guess-language-mode 1)))
  )
#+end_src
* Work environment
This will be my working environment config

#+begin_src emacs-lisp
;; Load this config when using the work computer
(if my-workenvironment-p
    (progn
      (org-babel-load-file "~/.doom.d/emacs-org-init-trabajo.org")
      )
  )
#+end_src
