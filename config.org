#+title: doom emacs config
#+author: Javier Castilla
#+EMAIL: jcastp@pm.me
#+language: en
* Summary
This is the literate config for my doom emacs use cases.

I will try to document and compartmentalize the sections, so it's easier to follow up, but it won't always be possible, as some functions overlap, and I'm usually a messy person when speaking of testing.

* General
** emacs lisp lexical binding
#+begin_src emacs-lisp :tangle yes
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src

** variable definition
I define here some very basic variables to configure several parts of the config.

*** Directories used by emacs
#+begin_src emacs-lisp
(defvar my-config-dir "~/.doom.d/"
  "Personal config directory.")

(defvar my-data-dir "~/Nextcloud/config/.emacs.d/"
  "Personal data directory.")
#+end_src

*** Machine names
#+begin_src emacs-lisp
;; working laptop vm
(defvar my-worksystem-p (equal (system-name) "lubuntuwork")
  "Name of my working machine.")

;; My desktop machine, able to run anything
(defvar my-desktopsystem-p (or
			    (equal (system-name) "olimpo")
			    (equal (system-name) "doomslayer"))
  "Names of my personal machines.")

;; Writing machines
;; probably we can strip some features from them, as they are low end machines
(defvar my-writinglaptop-p (or
			    (equal (system-name) "argos")
			    (equal (system-name) "caliope"))
  "Names of my writing laptops.")
#+end_src

*** Environments
#+begin_src emacs-lisp
(defvar my-homeenvironment-p (or
			      (string= (getenv "WORKING") "HOME")
			      (not (string= (getenv "WORKING") "WORK")))
  "My home environment predicate.")

(defvar my-workenvironment-p (string= (getenv "WORKING") "WORK")
  "My work environment predicate.")
#+end_src

*** Encrypted data directories
#+begin_src emacs-lisp
;; define my clear directory
(defvar my-clear-directory (expand-file-name "Nextcloud_claro/gocryptfs_claro" (getenv "HOME"))
  "My decrypted directory.")

;; check the directory exists
;;(file-directory-p my-clear-directory)

;; check if a directory is a mount point - against "mount" command in the OS.
(defun is-mount-point-p (path)
  "Check if the given PATH is a mount point."
  (let ((mount-output (shell-command-to-string "mount")))
    (string-match (regexp-quote path) mount-output)))

;; This variable will control if my encrypted dir is mounted on the clear directory
(defvar my-clear-directory-is-mounted-p 0
  "My clear directory is correctly mounted - predicate.")

;; Check if the directory is mounted
(if (is-mount-point-p my-clear-directory)
    ;; if it is mounted, we change the variable
    (setq my-clear-directory-is-mounted-p t)
  ;; if it is not mounted, then we should launch the script here
  (progn
    ;; I think we should not launch this from here, but just examine what is wrong in the OS.
    ;;(shell-command "bash ~/Nextcloud/config/mount-encrypted-dirs.sh")
    )
  )
#+end_src

** Personal information
Based on the environment variables.

This uses a special file, not commited, with my personal information, located in the path below.
It contains the variables =user-full-name= and =user-mail-address=
#+begin_src emacs-lisp
;; to protect my personal information, this file is not commited
(load (expand-file-name "personal_info.el" my-data-dir))
#+end_src
** Start with a maximized frame
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src
** undo-tree config
#+begin_src emacs-lisp :tangle yes
;; unmap the C-z keybinding
(global-unset-key (kbd "C-z"))
;; map C-z to undo
(map!
 "C-z" #'undo-tree-visualize)
#+end_src
** Save command history
It is nice to have commands and their history saved so that every time you get back to work, you can just re-run stuff as you need it. It isn't a radical feature, it is just part of a good user experience.

#+begin_src emacs-lisp
(setq savehist-file (expand-file-name "savehist" my-data-dir))
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring)
      )
#+end_src

** recentf
Configure where we save the recent files opened, so I don't loose them once I reinstall doom emacs.
#+begin_src emacs-lisp
;; where to store the recent list file
(after! recentf
  (setq recentf-save-file (expand-file-name "recentf" my-data-dir)))
#+end_src
** persp-save location
#+begin_src emacs-lisp
(use-package! persp-mode
  :config
  (setq persp-save-dir (expand-file-name "persp-confs/" my-data-dir))
)
#+end_src

** auto revert mode
When a file is changed in disk, the buffer reloads to reflect that change.
#+begin_src emacs-lisp
(global-auto-revert-mode 1)
#+end_src

** dired config
*** dired omit mode disabled
I want to see all the files in the directory.
#+begin_src emacs-lisp :tangle yes
(remove-hook 'dired-mode-hook 'dired-omit-mode)
#+end_src
*** dired hooked to auto revert
Change dired buffers when the directory is changed:
#+begin_src emacs-lisp :tangle yes
;; auto refresh dired when file changes
;; (add-hook 'dired-mode-hook 'auto-revert-mode)
#+end_src

** Bookmarks
All the config related to the bookmarks.

#+begin_src emacs-lisp
(setq bookmark-default-file (expand-file-name "bookmarks" my-data-dir))
(setq bookmark-save-flag 1)  ;save bookmarks to .emacs.bmk after each entry
#+end_src

** Abbreviation mode
Defines a set of abbreviations that permits complete words with just some characters.

#+begin_src emacs-lisp
;;where do we read the abbrevs from
(setq abbrev-file-name (expand-file-name "abbrev_defs" my-data-dir))
(setq-default abbrev-mode t)
;; save abbrevs when files are saved
(setq save-abbrevs 'silently)
#+end_src

** electric pair mode
To automatically close parenthesis and other punctuation signs.

#+begin_src emacs-lisp
(electric-pair-mode 1)
;; make electric-pair-mode work on more sets of punctuation signs.
(setq electric-pair-pairs
      '(
        (?\¡ . ?\!)
        (?\¿ . ?\?)
        )
      )

(setq electric-pair-inhibit-predicate
      `(lambda (c)
         (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))
      )
      #+end_src

** set firefox or librewolf as the default browser
Setting firefox or librewolf as the default browser for opening http/s links.
#+begin_src emacs-lisp
  (setq librewolf_path "/usr/bin/librewolf")
  ;; check if librewolf is installed
  (if (file-exists-p librewolf_path)
       (progn
         (setq browse-url-firefox-program "librewolf")
         (setq browse-url-browser-function 'browse-url-firefox))
    ;; if no librewolf installed, we fall back to firefox
     (progn
       (setq browse-url-firefox-program "firefox")
       (setq browse-url-browser-function 'browse-url-firefox)))
#+end_src

* UI
** Time and date
Put time and date on the status line

#+begin_src emacs-lisp
(setq display-time-day-and-date t
      display-time-24hr-format t)
(display-time)
#+end_src

** full path in the title bar
Put the complete path on the title bar, along the filename.

#+begin_src emacs-lisp
(setq-default frame-title-format "%b - (%f)")
#+end_src

** Battery management
On laptops it's nice to know how much power you have.

#+begin_src emacs-lisp
(unless (string-match-p "^Power N/A" (battery))
  (display-battery-mode 1)
  )
#+end_src

** Parens mode global
To show matching parens in all the buffers and modes.

#+begin_src emacs-lisp
(show-smartparens-global-mode 1)
#+end_src

** ace-window
To better manage more buffers in screen, as seen here: https://github.com/abo-abo/ace-window

Used in the hydra snippets.
#+begin_src emacs-lisp
(use-package! ace-window
  :config
  (setq aw-scope 'frame)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (global-set-key (kbd "M-o") 'ace-window)
  ;; make the characters bigger, so it is easy to see
  (custom-set-faces
   '(aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 3.0)))))
  )
#+end_src

** dimmer
I want to differentiate the window I'm working with.

#+begin_src emacs-lisp :tangle packages.el
(package! dimmer
  :recipe (:host github :repo "gonewest818/dimmer.el"))
#+end_src

#+begin_src emacs-lisp
;;(dimmer-configure-which-key)
(dimmer-mode t)
(dimmer-configure-magit)
(dimmer-configure-org)

;; configure the dimmer
(setq dimmer-adjustment-mode :both)
(setq dimmer-fraction 0.3)
#+end_src

** Initial theme
#+begin_src emacs-lisp :tangle yes
;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(setq doom-theme 'doom-one)
#+end_src

** line numbers
#+begin_src emacs-lisp :tangle yes
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type t)
#+end_src

** Define default fonts
#+begin_src emacs-lisp :tangle yes
;; Doom exposes five (optional) variables for controlling fonts in Doom:
;;
;; - `doom-font' -- the primary font to use
;; - `doom-variable-pitch-font' -- a non-monospace font (where applicable)
;; - `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;; - `doom-symbol-font' -- for symbols
;; - `doom-serif-font' -- for the `fixed-pitch-serif' face
;;
;; See 'C-h v doom-font' for documentation and more examples of what they
;; accept. For example:
;;
;;(setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
;;      doom-variable-pitch-font (font-spec :family "Fira Sans" :size 13))
;;
;; If you or Emacs can't find your font, use 'M-x describe-font' to look them
;; up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
;; refresh your font settings. If Emacs still can't find your font, it likely
;; wasn't installed correctly. Font issues are rarely Doom issues!
(setq doom-font (font-spec :family "DejaVu Sans Mono" :size 15 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "DejaVu Sans Mono" :size 15))
#+end_src

** Font size increase/decrease
Increase or decrease the font size.
#+begin_src emacs-lisp
(global-set-key (kbd "M-+") 'text-scale-increase)
(global-set-key (kbd "M--") 'text-scale-decrease)
#+end_src

** fontaine
I can change the fonts with just a single command.
https://protesilaos.com/emacs/fontaine

#+begin_src emacs-lisp :tangle packages.el
(package! fontaine
  :recipe (:host github :repo "protesilaos/fontaine"))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! fontaine
  :config
      (setq fontaine-presets
          '(
            ;; daily operations, same config as normal config
            (regular
             :default-family "Aporetic Sans Mono"
             :default-weight normal
             :default-height 120
             :fixed-pitch-family "Aporetic Sans Mono"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 110
             :variable-pitch-family "Aporetic Sans"
             :variable-pitch-weight Medium
             :variable-pitch-height 140
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "Aporetic Sans"
             :italic-slant italic
             :line-spacing 0
             )
            (regular-aporetic-mono
             :default-family "Aporetic Sans Mono"
             :default-weight normal
             :default-height 110
             :fixed-pitch-family "Aporetic Sans Mono"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 110
             :variable-pitch-family "Aporetic Sans Mono"
             :variable-pitch-weight Medium
             :variable-pitch-height 110
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "Aporetic Sans Mono"
             :italic-slant italic
             :line-spacing 0
             )
            ;; Bigger face for variable width, so I can focus on it
            (writing
             :default-family "ETBembo"
             :default-weight normal
             :default-height 150
             :fixed-pitch-family "Aporetic Sans Mono"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 120
             :variable-pitch-family "ETBembo"
             :variable-pitch-weight Medium
             :variable-pitch-height 150
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "ETBembo"
             :italic-slant italic
             :line-spacing 1
             )
            ;; Bigger face for variable width, so I can focus on it
            (writing-big
             :default-family "ETBembo"
             :default-weight normal
             :default-height 180
             :fixed-pitch-family "Aporetic Sans Mono"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 140
             :variable-pitch-family "ETBembo"
             :variable-pitch-weight Medium
             :variable-pitch-height 180
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "ETBembo"
             :italic-slant italic
             :line-spacing 1
             )
            ;; change the variable width face to have a different view when editing
            (editing
             :default-family "Aporetic Sans Mono"
             :default-weight normal
             :default-height 130
             :fixed-pitch-family "Aporetic Sans Mono"
             :fixed-pitch-weight nil ; falls back to :default-weight
             :fixed-pitch-height 110
             :variable-pitch-family "Gentium"
             :variable-pitch-weight normal
             :variable-pitch-height 150
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "Gentium"
             :italic-slant italic
             :line-spacing 1
             )
    	  ;; font for work
    	  (work
             :default-family "Aporetic Sans"
             :default-weight normal
             :default-height 120
             :fixed-pitch-family "Aporetic Sans Mono"
             :fixed-pitch-weight Light ; falls back to :default-weight
             :fixed-pitch-height 110
             :variable-pitch-family "Aporetic Sans"
             :variable-pitch-weight Medium
             :variable-pitch-height 120
             :bold-family nil ; use whatever the underlying face has
             :bold-weight bold
             :italic-family "Aporetic Sans"
             :italic-slant italic
             :line-spacing 0
             )
            )
          )
  )
#+end_src

** visual fill column
https://github.com/joostkremers/visual-fill-column
This mode restricts the lines up until a set margin, and wraps them logically at that point.

#+begin_src emacs-lisp :tangle yes
(setq visual-fill-column-width 110)
(setq visual-fill-column-center-text t)

;; Map the visual mode toggle
(map! :leader
      ;; remapping this as I don't use it that much
      :desc "visible mode"            "t V" #'visible-mode
      ;; assigning this to my more used visible-fill-column-mode
      :desc "visual fill column"      "t v" #'visual-fill-column-mode
      )
#+end_src

** pulsar - line flash when jumping
I want to know where my cursor is when jumping or when I press some keybinding.
#+begin_src emacs-lisp :tangle packages.el
(package! pulsar)
#+end_src

#+begin_src emacs-lisp :tangle yes
(pulsar-global-mode 1)
(setq pulsar-delay 0.1)
(setq pulsar-iterations 10)
(setq pulsar-face 'pulsar-yellow)
(setq pulsar-region-face 'pulsar-yellow)
(setq pulsar-highlight-face 'pulsar-magenta)

(map!
 "C-x l" #'pulsar-pulse-line
 "C-x L" #'pulsar-highlight-permanently-dwim)
#+end_src
* Navigation
** Movement for paragraphs
Some keys redefined to better adjust to the whole emacs key environment.
#+begin_src emacs-lisp
(global-set-key (kbd "M-p") 'backward-paragraph)
(global-set-key (kbd "M-n") 'forward-paragraph)
#+end_src

** consult-line to C-s
#+begin_src emacs-lisp :tangle yes
(map!
      "C-s" #'consult-line
      "M-y" #'consult-yank-from-kill-ring
      "M-i" #'consult-imenu
      "M-g i" #'consult-imenu-multi
      "M-g h" #'consult-org-heading
      "M-g m" #'consult-mark
      "M-s f" #'consult-find
      "M-s r" #'consult-ripgrep
      )
#+end_src

** avy can select from any window
To make avy able to select from any window in sight. This allows to change from one window to another in just one step.
#+begin_src emacs-lisp :tangle yes
(setq avy-all-windows t)
#+end_src

** Keyboard chords
Shortcuts to commands using just quick key combinations.

#+begin_src emacs-lisp :tangle packages.el
(package! key-chord)
#+end_src

#+begin_src emacs-lisp
(use-package! key-chord
  :config
  (key-chord-mode 1)
  ;; Max time delay between two presses of the same key to be considered a key chord.
  ;; Should normally be a little longer than `key-chord-two-keys-delay'.
  (setq key-chord-two-keys-delay 0.1)
  (setq key-chord-one-key-delay 0.2) ; default 0.2
  (key-chord-define-global "ññ" 'eshell)
  (key-chord-define-global "kk" 'other-window)
  (key-chord-define-global "hh" 'ace-window)
  (key-chord-define-global "jj" 'avy-goto-char-2)
  (key-chord-define-global "jk" 'avy-goto-char-timer)
  (key-chord-define-global "jl" 'avy-goto-line)
  ;;(key-chord-define-global "zz" 'undo-tree-visualize)
  ;;(key-chord-define-global "ww" 'hydra-move/body)
  ;;(key-chord-define-global "yy" 'hydra-buffer-mgmt/body)
  )
#+end_src

** imenu-list
Better menus list.

#+begin_src emacs-lisp :tangle packages.el
(package! imenu-list
  :recipe (:host github :repo "bmag/imenu-list"))
#+end_src

#+begin_src emacs-lisp
(after! imenu-list
  ;; put the imenu in the position we want to
  (setq imenu-list-position 'right)
  ;; Establish the depth of the entries shown
  (setq org-imenu-depth 5)
  (setq imenu-list-size 0.2)
  ;; Once you open imenu, focus on it
  (setq imenu-list-focus-after-activation t))

;; configuring the keybinding as /la/ doom emacs
;; https://rameezkhan.me/posts/2020/2020-07-03--adding-keybindings-to-doom-emacs/
(map! :leader
      :desc "imenu toggle"
      "s I" #'imenu-list-smart-toggle)
#+end_src

** avy keyconfig
I want to map the avy jump functions to some doom emacs keybindings.

#+begin_src emacs-lisp :tangle yes
(map! :leader
      (:prefix-map ("j" . "jump")
       :desc "jump to 2 chars"           "j"   #'avy-goto-char-2
       :desc "jump to chars-timer"       "k"   #'avy-goto-char-timer
       :desc "jump to line"              "l"   #'avy-goto-line))
#+end_src

** Open indirect buffer
Open a branch into a different frame, but the same buffer:

#+begin_src emacs-lisp
;; this is done to open the indirect buffer in another window
;; instead on the main one
(use-package! org
  :config
  (setq org-indirect-buffer-display 'other-window)

  (defun my/org-tree-open-in-right-frame ()
    "Open the subtree in a dedicated buffer."
    (interactive)
    (org-tree-to-indirect-buffer)
    ;;(windmove-right)
    (other-window 1) ;; to move to the newly generated window
    )

  (map! :leader
        :desc "Open org tree to indirect buffer"
        "8" #'my/org-tree-open-in-right-frame)
  )
  #+end_src
  
** hydra
#+begin_src emacs-lisp :tangle packages.el
;; loading the lv package, as it is required by hydra
(package! lv)
(package! hydra)
#+end_src

** Nov.el
Read e-pub in emacs.

https://tech.toryanderson.com/2022/11/23/viewing-epub-in-emacs/

#+begin_src emacs-lisp :tangle packages.el
  (package! esxml
    :recipe (:host github :repo "tali713/esxml"))

   (package! nov
     :recipe (:host nil :repo "https://depp.brause.cc/nov.el.git"))
#+end_src


#+begin_src emacs-lisp
(use-package! nov
     :config
     (setq nov-text-width t)
     (setq visual-fill-column-center-text t)
     (add-hook 'nov-mode-hook 'visual-line-mode)
     (add-hook 'nov-mode-hook 'visual-fill-column-mode)
     ;; We save the place we left the e-pub in this file:
     (setq nov-save-place-file (expand-file-name "nov-places" my-data-dir))
     ;; Define the font used for the nov.el mode
     (defun my-nov-font-setup ()
       (face-remap-add-relative 'variable-pitch :family "Liberation Serif"
                                :height 1.5))
     (add-hook 'nov-mode-hook 'my-nov-font-setup)
     (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
     )
#+end_src

** calibre
https://github.com/chenyanming/calibredb.el

#+begin_src emacs-lisp :tangle packages.el
(package! calibredb)
#+end_src

#+begin_src emacs-lisp
;; load this only on my home env
  (if (and
       my-homeenvironment-p
       ;; the calibre library ddbb exists
       (file-exists-p "/home/calibre_libros/metadata.db"))
      (progn
        ;; here comes the actions I want to be done at a home environment
        (use-package! calibredb
          :config
          (setq calibredb-root-dir "/home/calibre_libros/")
          (setq calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir))
          (setq calibredb-library-alist '(("/home/calibre_libros/")
                                          ))
          (setq calibredb-size-show t)
          (setq calibredb-id-width 10)
          )))
#+end_src

* Org config
** org directory config
#+begin_src emacs-lisp
;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/org/")
#+end_src

** some org configs for better behavior and usage
#+begin_src emacs-lisp
(after! org
  (setq
   ;; tag alignment
   ;; this value allows for modern themes and column fill to work well together.
   org-auto-align-tags t
   org-tags-column -100
   ;; org fold - edit in an invisible region
   org-fold-catch-invisible-edits 'show-and-error
   ;; C-a and C-e will move the cursor just the heading. No todo keyworks, no tags
   org-special-ctrl-a/e t
   ;; insert new heading after the current subtree
   org-insert-heading-respect-content t
   ;; we can close parent tasks even if successors are still open
   org-enforce-todo-dependencies nil
   ))
   #+end_src

** org heading numbering
I like to have numbering in the org headings.
#+begin_src emacs-lisp :tangle yes
(add-hook 'org-mode-hook 'org-num-mode)
#+end_src

** org-id
To create and use internal valid and unique links in org-mode, we will use the =org-id= features.
#+begin_src emacs-lisp
(after! org
  ;; org-id are globally unique UUIDs
  (setq org-id-method 'uuid)
  ;; It will use the CUSTOM_ID, if it exists
  ;;or will create a new one in the form or UUID, as seen above
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  ;; file to store the local =org-id= locations
  ;; This way is synced to all my computers
  (setq org-id-locations-file (expand-file-name "org-id-locations" my-data-dir)))
#+end_src

** Completion notes in to the Logbook
Change notes are stored in the node's drawer, so we can fold it conveniently.
#+begin_src emacs-lisp
(after! org
  (setq org-log-into-drawer t))
#+end_src

** Custom states for the tasks
These are the custom states for the tasks, and the character associated to it.

#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
        '(
          ;; Status for tasks
          (sequence "TODO(t)" "ONGOING(o)" "WAITING(w@/!)" "|" "DONE(d!)" "CANCELED(c@/!)")
          ;; Status for writing
          (sequence "TOWRITE(j)" "TOREVIEW(k@/!)" "REDO(l@/!)" "|" "FINISHED(ñ)" "PURGE(p@/!)"))))
#+end_src

** orgmode Agenda

All the agenda configs

*** Agenda files
We define the agenda files in this variable

#+begin_src emacs-lisp
(after! org
  (setq org-agenda-files '(
                           ;; normal task files
                           "~/Nextcloud/agenda/tasks.org"
                           ;; added this one to be able to search in it, and add from here to the main task files.
                           "~/Nextcloud/agenda/someday.org")))
#+end_src

*** icons for the agenda categories
Have some fancy icons for the categories.
#+begin_src emacs-lisp
(after! org
  (customize-set-value
   'org-agenda-category-icon-alist
   `(
     ("calendar" "~/Nextcloud/config/icons/calendar.svg" nil nil :ascent center :mask heuristic)
     ("tasks" "~/Nextcloud/config/icons/check-square.svg" nil nil :ascent center :mask heuristic)
     ("projects" "~/Nextcloud/config/icons/list.svg" nil nil :ascent center :mask heuristic)
     ("financial" "~/Nextcloud/config/icons/dollar-sign.svg" nil nil :ascent center :mask heuristic)
     ("birthdays" "~/Nextcloud/config/icons/heart.svg" nil nil :ascent center :mask heuristic)
     ("revision" "~/Nextcloud/config/icons/shuffle.svg" nil nil :ascent center :mask heuristic)
     ("habits" "~/Nextcloud/config/icons/refresh-ccw.svg" nil nil :ascent center :mask heuristic)
     ("care" "~/Nextcloud/config/icons/heart.svg" nil nil :ascent center :mask heuristic))))
#+end_src

*** Get rid of the DONE tasks in the agenda view
We dont want the cluttering in our views. If a task is done, don't show it on the agenda view.

#+begin_src emacs-lisp
(after! org
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-timestamp-if-done t))
#+end_src

** Capture templates
Here I will add template captures for doing several things:

#+begin_src emacs-lisp :tangle yes
(after! org
  (setq org-capture-templates'(
                               ;; task related captures
                               ("t" "My TODO task format." entry
                                (file+headline "~/Nextcloud/agenda/tasks.org" "Tasks")
                                "** TODO %i%? %^g\n:PROPERTIES:\n:CATEGORY: tasks\n:END:\n"
                                :empty-lines-after 1)

                               ("p" "New project." entry
                                (file+headline "~/Nextcloud/agenda/tasks.org" "Tasks")
                                "** TODO %? %^g\n:PROPERTIES:\n:COOKIE_DATA: todo recursive\n:CATEGORY: project\n:END:\n"
                                :empty-lines-after 1)

                               ;; Writing related things

                               ;; Everything that I find interesting to create, no matter what it is
                               ("h" "Compost heap" item
                                (file+headline "~/Nextcloud/escritura/retazos/compost_heap.org" "Compost heap")
                                "%i"
                                :empty-lines-after 1)

                               ;; A possible writing idea
                               ("w" "Writing idea." entry
                                (file+headline "~/Nextcloud/escritura/retazos/ideas.org" "Ideas")
                                "** TODO %?\n*** Personajes\n- \n*** Ambientación\n*** Eventos\n"
                                :empty-lines-after 1)

                               ;; An interesenting character
                               ("P" "Personaje" entry
                                (file "~/Nextcloud/escritura/retazos/personajes.org")
                                "* %i%?"
                                :empty-lines-after 1)
                               )))
  #+end_src

** org-ql
https://github.com/alphapapa/org-ql
#+begin_src emacs-lisp :tangle packages.el
(package! org-ql)
#+end_src

** Capture to this buffer
Inspired by https://github.com/ballantony/emacs-writing/blob/main/DoomEmacsWriting.org

Used to capture notes in this file. Useful to maintain notes and snippets separated by projects.
#+begin_src emacs-lisp
(after! org
  (defun my/capture-to-this-buffer ()
    "Capture a note to the current buffer’s file, under the headline \"Notes\")."
    (interactive)
    ;; Make sure we are in an Org buffer.
    (unless (derived-mode-p 'org-mode)
      (user-error "Can’t capture to a non‑Org buffer"))

    ;; Choose the destination that actually exists.
    (let ((target (buffer-file-name)))
      ;; Build a temporary capture template that points at TARGET.
      (let ((org-capture-templates
             `(("t" "Todo"
                entry
                (file+headline ,target "Notes")
                "** TODO %?"))))
        ;; Run the capture UI.
        (org-capture)))))
#+end_src

** Orgmode org-roam config
Org-roam related config.
*** org-roam general configuration

This is a fix for a Debian installation that doesn't allow to connect directly to the sqlite backend. As seen here: https://github.com/magit/emacsql/blob/main/emacsql-sqlite.el
#+begin_src emacs-lisp
(defun which-linux-distribution ()
  "from lsb_release"
  (interactive)
  (when (eq system-type 'gnu/linux)
    (shell-command-to-string "lsb_release -sd")))

;; (when (string-prefix-p "Debian" (which-linux-distribution))
;;   (use-package sqlite3
;;     :ensure t))
#+end_src

#+begin_src emacs-lisp
  ;; main org-roam config
(use-package! org-roam
  :init
  ;; Create the new directory to store roam notes
  (setq org-roam-directory (file-truename "~/Nextcloud/personal/roam"))
  ;; Location of the roam database
  (setq org-roam-db-location (file-truename "~/Nextcloud/personal/roam/org-roam.db"))
  :config
  ;; provide org-roam completion links outside org files.
  (setq org-roam-completion-everywhere t)
  ;; Ensure the keymap is available
  (require 'org-roam-dailies)
  ;; org-roam export: https://www.orgroam.com/manual.html#org_002droam_002dexport
  (require 'org-roam-export)
  ;; autosync
  (org-roam-db-autosync-mode 1))
#+end_src

Open the fleeting notes with a keybinding:
#+begin_src emacs-lisp
;; (defun my/org-roam-fleeting-notes()
;;   "Open my org-roam file with my fleeting notes"
;;   (interactive)
;;   (find-file "~/Nextcloud/personal/roam/fleeting_notes.org"))
;; (global-set-key (kbd "C-c n F") 'my/org-roam-fleeting-notes)
#+end_src

Org-roam capture templates:
#+begin_src emacs-lisp
;; TODO change these paths to variables: we can try concat or expand-file-name
;; org-roam templates
(setq org-roam-capture-templates
      '(
        ;; default template
        ("d" "default" plain
         "* TODO ${title}\n%?"
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
         :unnarrowed t)
        ("b" "book notes" plain (file "~/.doom.d/roamtemplates/BookNoteTemplate.org")
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: book")
         :unnarrowed t)
        ("w" "writing idea" plain (file "~/.doom.d/roamtemplates/WritingIdea.org")
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: writing")
         :unnarrowed t)
        ("c" "writing character" plain (file "~/.doom.d/roamtemplates/CharacterIdea.org")
         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n#+filetags: writing character")
         :unnarrowed t)))
#+end_src

Org-roam window configuration and showing:
#+begin_src emacs-lisp
;; How the roam window shows
;; (add-to-list 'display-buffer-alist
;;              '("\\*org-roam\\*"
;;                (display-buffer-in-side-window)
;;                (side . right)
;;                (slot . 0)
;;                (window-width . 0.33)
;;                (window-parameters . ((no-other-window . t)
;;                                      (no-delete-other-windows . t)))))
#+end_src

Search by title and tags:
#+begin_src emacs-lisp
;; To search by title and tags, we will use the information contained here:
;; https://github.com/org-roam/org-roam/pull/2054
(setq org-roam-node-display-template
      (concat "${title:*} "
              (propertize "${tags:20}" 'face 'org-tag)))
#+end_src

*** org-roam UI
I want to check a graphical view of my notes:
#+begin_src emacs-lisp :tangle packages.el
;; org-roam-ui and its dependencies
;; simple httpd
(package! websocket)
(package! simple-httpd)
(package! org-roam-ui)
#+end_src


#+begin_src emacs-lisp :tangle yes
(use-package! org-roam
  :hook (org-roam . org-roam-ui-mode))
#+end_src

#+begin_src emacs-lisp :tangle yes
;; Daily notes for org-roam
;; Directory is relative to org-roam-directory
(setq org-roam-dailies-directory "daily/")


;; Capture template for the dailies
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry
         "* %?"
         :if-new (file+head "%<%Y-%m-%d>.org"
                            "#+title: %<%Y-%m-%d>\n#+filetags: daily\n"))))
#+end_src

*** Restrict agenda to org mode
Functions to isolate the org-roam TODOs from my general agenda.
Extracted from https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html
#+begin_src emacs-lisp
;; I want to get all my org-roam TODOs in the agenda view, but I need to do it only with
;; the files that contain the TODO keywords, and not the whole org-roam directory.

;; https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html

;; we want to load these functions if org-roam is present
(if (not(require 'org-roam nil t))
    ;; if condition
    (message "org-roam not found")
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; else condition

  (setq my/roamtag "roamtag")

  (defun vulpea-buffer-prop-set (name value)
    "Set a file property called NAME to VALUE in buffer file.
      If the property is already set, replace its value."
    (setq name (downcase name))
    (org-with-point-at 1
      (let ((case-fold-search t))
        (if (re-search-forward (concat "^#\\+" name ":\\(.*\\)")
                               (point-max) t)
            (replace-match (concat "#+" name ": " value) 'fixedcase)
          (while (and (not (eobp))
                      (looking-at "^[#:]"))
            (if (save-excursion (end-of-line) (eobp))
                (progn
                  (end-of-line)
                  (insert "\n"))
              (forward-line)
              (beginning-of-line)))
          (insert "#+" name ": " value "\n")))))

  (defun vulpea-buffer-prop-set-list (name values &optional separators)
    "Set a file property called NAME to VALUES in current buffer.
      VALUES are quoted and combined into single string using
      `combine-and-quote-strings'.
      If SEPARATORS is non-nil, it should be a regular expression
      matching text that separates, but is not part of, the substrings.
      If nil it defaults to `split-string-default-separators', normally
      \"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t.
      If the property is already set, replace its value."
    (vulpea-buffer-prop-set
     name (combine-and-quote-strings values separators)))

  (defun vulpea-buffer-tags-set (&rest tags)
    "Set TAGS in current buffer.
        If filetags value is already set, replace it."
    (vulpea-buffer-prop-set "filetags" (string-join tags " ")))

  (defun vulpea-buffer-prop-get (name)
    "Get a buffer property called NAME as a string."
    (org-with-point-at 1
      (when (re-search-forward (concat "^#\\+" name ": \\(.*\\)")
                               (point-max) t)
        (buffer-substring-no-properties
         (match-beginning 1)
         (match-end 1)))))


  (defun vulpea-buffer-prop-get-list (name &optional separators)
    "Get a buffer property NAME as a list using SEPARATORS.
          If SEPARATORS is non-nil, it should be a regular expression
          matching text that separates, but is not part of, the substrings.
          If nil it defaults to `split-string-default-separators', normally
          \"[ \f\t\n\r\v]+\", and OMIT-NULLS is forced to t."
    (let ((value (vulpea-buffer-prop-get name)))
      (when (and value (not (string-empty-p value)))
        (split-string-and-unquote value separators))))

  (defun vulpea-buffer-tags-get ()
    "Return filetags value in current buffer."
    (vulpea-buffer-prop-get-list "filetags" " "))

  (defun vulpea-buffer-tags-add (tag)
    "Add a TAG to filetags in current buffer."
    (let* ((tags (vulpea-buffer-tags-get))
           (tags (append tags (list tag))))
      (apply #'vulpea-buffer-tags-set tags)))



  (defun vulpea-project-p ()
    "Return non-nil if current buffer has any todo entry.

              TODO entries marked as done are ignored, meaning the this
              function returns nil if current buffer contains only completed
              tasks."
    (seq-find                                 ; (3)
     (lambda (type)
       (eq type 'todo))
     (org-element-map                         ; (2)
         (org-element-parse-buffer 'headline) ; (1)
         'headline
       (lambda (h)
         (org-element-property :todo-type h)))))

  (defun vulpea-project-update-tag ()
    "Update PROJECT tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (vulpea-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (vulpea-buffer-tags-get))
               (original-tags tags))
          (if (vulpea-project-p)
              (setq tags (cons "roamtag" tags))
            (setq tags (remove "roamtag" tags)))

          ;; cleanup duplicates
          (setq tags (seq-uniq tags))

          ;; update tags if changed
          (when (or (seq-difference tags original-tags)
                    (seq-difference original-tags tags))
            (apply #'vulpea-buffer-tags-set tags))))))

  (defun vulpea-buffer-p ()
    "Return non-nil if the currently visited buffer is a note."
    (and buffer-file-name
         (string-prefix-p
          (expand-file-name (file-name-as-directory org-roam-directory))
          (file-name-directory buffer-file-name))))

  (defun vulpea-project-files ()
    "Return a list of note files containing 'roamtag' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
        :from tags
        :left-join nodes
        :on (= tags:node-id nodes:id)
        :where (like tag (quote "%\"roamtag\"%"))]))))




  ;; ---------------------------------
  ;; this is the agenda part

  ;; This will overwrite the current agenda files, and we don't want that
  ;; (defun vulpea-agenda-files-update (&rest _)
  ;;   "Update the value of `org-agenda-files'."
  ;;   (setq org-agenda-files (vulpea-project-files)))

  ;; (defun inject-vulpea-project-files (org-agenda-files)
  ;;   (append org-agenda-files (vulpea-project-files)))
  ;; (advice-add 'org-agenda-files :filter-return #'inject-vulpea-project-files)

  (add-hook 'find-file-hook #'vulpea-project-update-tag)
  (add-hook 'before-save-hook #'vulpea-project-update-tag)

  ;; ;; original code that overwrites the agenda files (using the one above, this one is just for training)
  ;;  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
  ;;  (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)
  )
#+end_src

Just show the TODOs from org-roam, and not from the general agenda.

#+begin_src emacs-lisp
(defun my/agenda-restrict-to-roam ()
  "Restrict agenda to current project"
  (interactive)
  (let ((org-agenda-files (list org-roam-directory)))
    (org-agenda)))
;;(global-set-key (kbd "C-c n a") 'my/agenda-restrict-to-roam)
#+end_src

*** org-roam random node opening
Opens a random org-roam node.

#+begin_src emacs-lisp
(defun my/random-roam-node ()
  "Opens a random org-roam node."
  (interactive)
  (setq todo-nodes
        (org-roam-db-query
         ;; select the nodes that have the roamtag tag
         [:select [nodes:file]
          :from tags
          :left-join nodes
          :on (= tags:node-id nodes:id)
  	  ]
  	 )
        )
  ;; get a random file from the list and open it
  (find-file (car (nth (random (length todo-nodes)) todo-nodes))))

;; (global-set-key (kbd "C-c n R") 'my/random-roam-node)
#+end_src

Open a random roam node with the roamtag tag (that maps to a TODO entry).
#+begin_src emacs-lisp
(defun my/random-roam-todo-node ()
  "Opens a random org-roam node with the roamtag tag."
  (interactive)
  (setq todo-nodes
        (org-roam-db-query
         ;; select the nodes that have the roamtag tag
         [:select [nodes:file]
          :from tags
          :left-join nodes
          :on (= tags:node-id nodes:id)
          :where (like tag (quote "%\"roamtag\"%"))])
        )
  ;; get a random file from the list and open it
  (find-file (car (nth (random (length todo-nodes)) todo-nodes))))

;; (global-set-key (kbd "C-c n T") 'my/random-roam-todo-node)
#+end_src

** Create an org scratch buffer
https://emacs.stackexchange.com/questions/16492/is-it-possible-to-create-an-org-mode-scratch-buffer

When you want to write something fast using org mode, but you don't want to create a new file.

#+begin_src emacs-lisp
(defun my/scratch-org-buffer ()
  "Create a new scratch buffer -- \*hello-world\*"
  (interactive)
  (let ((n 0)
        bufname buffer)
    (catch 'done
      (while t
        (setq bufname (concat "*org-scratch"
                              (if (= n 0) "" (int-to-string n))
                              "*"))
        (setq n (1+ n))
        (when (not (get-buffer bufname))
          (setq buffer (get-buffer-create bufname))
          (with-current-buffer buffer
            (org-mode)
            (insert "# org-scratch buffer\n"))
          ;; When called non-interactively, the `t` targets the other window (if it exists).
          (throw 'done (select-window (display-buffer buffer t))))))))

(map! :leader
      :desc "Open an org scratch buffer"
      "f o" #'my/scratch-org-buffer)
#+end_src

** Orgmode export config
All the functions defined for the org mode export

*** Ignore exporting some headlines (just the headlines)
This allows headlines to be ignored in the exports. To do so, the ignore tag (=C-c C-c ignore=) has to be in the header to be ignored. *We only ignore the headlines, the content is still shown.*

#+begin_src emacs-lisp :tangle packages.el
(package! org-contrib)
#+end_src

#+begin_src emacs-lisp
  ;;(load (expand-file-name "vendor/ox-extra/ox-extra.el" my-data-dir))
  (use-package! org-contrib
    :ensure t
    :config
    (require 'ox-extra)
    (ox-extras-activate '(ignore-headlines)))
#+end_src

*** TODO Latex export
All the latex exports in just one place.

Config extracted from the Emacs Writing Studio ebook.
#+begin_src emacs-lisp
  (use-package ox-latex
    :ensure nil
    :demand t
    :custom
    ;; Multiple LaTeX passes for bibliographies
    (org-latex-pdf-process
     '("pdflatex -interaction nonstopmode -output-directory %o %f"
       "bibtex %b"
       "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
       "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
    ;; Add smart quotes for latex
    (org-export-with-smart-quotes t)
    ;; Clean temporary files after export
    (org-latex-logfiles-extensions
     (quote ("lof" "lot" "tex~" "aux" "idx" "log" "out"
             "toc" "nav" "snm" "vrb" "dvi" "fdb_latexmk"
             "blg" "brf" "fls" "entoc" "ps" "spl" "bbl"
             "tex" "bcf"))))
#+end_src
**** ews format
Extracted from the Emacs Writing Studio config.

#+begin_src emacs-lisp
  (with-eval-after-load 'ox-latex
    (add-to-list
     'org-latex-classes
     '("ews"
       "\\documentclass[11pt, twoside, hidelinks]{memoir}
      \\setstocksize{9.25in}{7.5in}
      \\settrimmedsize{\\stockheight}{\\stockwidth}{*}
      \\setlrmarginsandblock{2cm}{1cm}{*}
      \\setulmarginsandblock{1.5cm}{2.25cm}{*}
      \\checkandfixthelayout
      \\setcounter{tocdepth}{0}
      \\OnehalfSpacing
      \\usepackage{ebgaramond}
      \\usepackage[htt]{hyphenat}
      \\chapterstyle{bianchi}
      \\setsecheadstyle{\\normalfont \\raggedright \\textbf}
      \\setsubsecheadstyle{\\normalfont \\raggedright \\textbf}
      \\setsubsubsecheadstyle{\\normalfont\\centering}
      \\renewcommand\\texttt[1]{{\\normalfont\\fontfamily{cmvtt}
        \\selectfont #1}}
      \\usepackage[font={small, it}]{caption}
      \\pagestyle{myheadings}
      \\usepackage{ccicons}
      \\usepackage[authoryear]{natbib}
      \\bibliographystyle{apalike}
      \\usepackage{svg}"
       ("\\chapter{%s}" . "\\chapter*{%s}")
       ("\\section{%s}" . "\\section*{%s}")
       ("\\subsection{%s}" . "\\subsection*{%s}")
       ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src

**** Consolidated Memoir LaTeX Export Classes
https://www.ctan.org/pkg/memoir
https://mirror.ibcp.fr/pub/CTAN/macros/latex/contrib/memoir/memman.pdf
=memoir= is a class used to create beautiful documents.

This consolidated function creates all memoir variants (draft/final, with parts/chapter-only).

#+begin_src emacs-lisp
  (defun my/add-memoir-class (name &optional draft chapter-only)
    "Add memoir LaTeX class with NAME.
  When DRAFT is non-nil, enable draft mode.
  When CHAPTER-ONLY is non-nil, start with chapters (no parts)."
    (let* ((draft-option (if draft ",draft" ",final"))
           (levels (if chapter-only
                       ;; Chapter-only: no \\part level
                       '(("\\chapter{%s}" . "\\chapter*{%s}")
                         ("\\section{%s}" . "\\section*{%s}")
                         ("\\subsection{%s}" . "\\subsection*{%s}")
                         ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                         ("\\paragraph{%s}" . "\\paragraph*{%s}")
                         ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
                     ;; Standard: includes \\part level
                     '(("\\part{%s}" . "\\part*{%s}")
                       ("\\chapter{%s}" . "\\chapter*{%s}")
                       ("\\section{%s}" . "\\section*{%s}")
                       ("\\subsection{%s}" . "\\subsection*{%s}")
                       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                       ("\\paragraph{%s}" . "\\paragraph*{%s}")
                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
           (preamble (format "\\documentclass[a4paper,17pt%s,openright,twoside]{memoir}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}
  \\usepackage{minted}

  %% Para poner notas en los márgenes
  \\usepackage{todonotes}

  %% Para tachar palabras
  \\usepackage[normalem]{ulem}

  %% for hyperlinks in the pdf
  \\usepackage{hyperref}
  %% space between the paragraphs
  \\usepackage{parskip}
  %% Needed for the utopia font
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  %% new command that establish 3 newlines for breaking scenes
  \\newcommand{\\fin}{\\plainbreak*{3}}

  %% command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}

  %% Chapter style
  \\chapterstyle{dash}

  %% How the page is formatted
  \\pagestyle{Ruled}

  %% change the paragraph spacing
  \\setlength{\\parskip}{0.2\\baselineskip}

                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]" draft-option)))
      (add-to-list 'org-latex-classes
                   `(,name ,preamble ,@levels))))

  ;; Create all four memoir class variants
  (my/add-memoir-class "memoir" nil nil)           ; Standard with parts
  (my/add-memoir-class "memoir_draft" t nil)       ; Draft with parts
  (my/add-memoir-class "memoir_chapter" nil t)     ; Final, chapter-only
  (my/add-memoir-class "memoir_chapter_draft" t t) ; Draft, chapter-only
#+end_src

**** TODO reporting class for org2latex (complete these options)

#+begin_src emacs-lisp
  (add-to-list 'org-latex-classes
  	     '("reporting"
                 "\\documentclass[a4paper,17pt,openright,twoside]{article}
  \\usepackage{ucs}
  \\usepackage[utf8]{inputenc}
  \\usepackage[spanish]{babel}
  \\usepackage{fontenc}
  \\usepackage{graphicx}

  \% Para poner notas en los márgenes
  \\usepackage{todonotes}

  \% Para tachar palabras
  \\usepackage[normalem]{ulem}

  \\usepackage{hyperref}
  \\usepackage{parskip}
  \\usepackage{fourier}

  \\renewcommand*\\rmdefault{put}

  \\newcommand{\\fin}{\\plainbreak*{3}}

  \% command to add edit notes with tiny size
  \\newcommand{\\edit}[1] {\\todo[inline]{#1}}
  \\newcommand{\\adendo}[1] {\\todo[size=\\tiny]{#1}}




                 [NO-DEFAULT-PACKAGES]
                 [NO-PACKAGES]"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section*{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
               )

#+end_src
** org habits
I want to track some habits in orgmode:
#+begin_src emacs-lisp :tangle yes
(add-to-list 'org-modules 'org-habit t)
#+end_src

* Writing
** Default dictionary
I write more and more in spanish. I will take the spanish dictionary as the default one, and will be adding the en_US one as ispell-local-dictionary local variable in the files I need it.

Also adding the "spanish" path, because somehow it doesn't work. It finds "castellano", but not "spanish".

#+begin_src emacs-lisp :tangle no
(after! ispell
  (setq ispell-dictionary "es_ES")
  (add-to-list 'ispell-hunspell-dict-paths-alist '("spanish" "/usr/share/hunspell/es_ES.aff")))
#+end_src

** org-journal
This is for journaling every day, if possible.
Documentation can be found here:

https://github.com/bastibe/org-journal

#+begin_src emacs-lisp
;;("C-c r ñ" . org-journal-new-entry)
(use-package! org-journal
  :config
  (setq org-journal-date-prefix "#+TITLE: ")
  (setq org-journal-file-format "%Y-%m-%d.org")
  (setq org-journal-dir (expand-file-name "personal/diario" my-clear-directory))
  (setq org-journal-date-format "%A, %d %B %Y")
  (setq org-journal-encrypt-journal nil)
  )
#+end_src

** CANCELED guess-language
Since I write in different languages, the dictionary applied is really important. If I write in Spanish, I want the spanish dict to be applied, and not the english one.

#+begin_src emacs-lisp :tangle no
(package! guess-language)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! guess-language
    :ensure t
    :config
    (setq guess-language-languages '(en es))
    (setq guess-language-min-paragraph-length 40)
    ;; define the dicts I want to use for my languages
    (setq guess-language-langcodes
	  '((en . ("en_US" "English"))
	    (es . ("es_ES" "Spanish"))))
    (guess-language-mode)
    ;; activate the mode when I go to text files
    (add-hook 'text-mode-hook (lambda () (guess-language-mode 1)))
    (add-hook 'org-mode-hook (lambda () (guess-language-mode 1)))
    )
#+end_src

** Translate from english
https://github.com/lorniu/gt.el
Translate from english to spanish

#+begin_src emacs-lisp :tangle packages.el
(package! gt)
#+end_src

#+begin_src emacs-lisp
(use-package! gt
  :ensure t
  :config
  (setq gt-langs '(en es))
  ;; Configure the default translator
  (setq gt-default-translator
	(gt-translator
	 ;; Optional: Use a more specific Taker to ensure correct language handling
	 ;; This Taker focuses on the word or selected region, using the global gt-langs
	 :taker (gt-taker :langs gt-langs :text 'word)
	 ;; Specify the translation engine(s)
	 :engines (gt-bing-engine)
	 ;; Optional: Change the output method for potentially better readability
	 ;; For example, using a dedicated buffer instead of the echo area:
	 ;; :render (gt-buffer-render)
	 ;; Or using a floating window:
	 ;; :render (gt-posframe-pop-render)
	 ;; The default render (gt-render) outputs to the echo area.
	 )))
#+end_src

** TODO powerthesaurus
https://github.com/SavchenkoValeriy/emacs-powerthesaurus

#+begin_src emacs-lisp :tangle packages.el
(package! powerthesaurus)
#+end_src

#+begin_src emacs-lisp
  (use-package! powerthesaurus
    :ensure t)
#+end_src

** org-remark for text annotations
Text annotations in org mode
https://github.com/nobiot/org-remark
Manual: https://nobiot.github.io/org-remark/

#+begin_src emacs-lisp :tangle packages.el
(package! org-remark)
#+end_src

#+begin_src emacs-lisp
  (use-package! org-remark
    :ensure t
    :after org
    :config
    (require 'org-remark-global-tracking)
    (org-remark-global-tracking-mode +1)

    ;; Create a file of notes for each file, with the buffer name appended by "-notes"
    (defun my/org-remark-file-name ()
      (concat (file-name-base (org-remark-notes-file-name-function))
              ".org"))
    (setq org-remark-notes-file-name
          #'my/org-remark-file-name)

    ;; Key-bind `org-remark-mark' to global-map so that you can call it
    ;; globally before the library is loaded.
    (define-key global-map (kbd "C-c n m") #'org-remark-mark)
    ;; The rest of keybidings are done only on loading `org-remark'
    (with-eval-after-load 'org-remark
      (define-key org-remark-mode-map (kbd "C-c n o") #'org-remark-open)
      (define-key org-remark-mode-map (kbd "C-c n n") #'org-remark-view-next)
      (define-key org-remark-mode-map (kbd "C-c n p") #'org-remark-view-prev)
      (define-key org-remark-mode-map (kbd "C-c n r") #'org-remark-remove)
      (define-key org-remark-mode-map (kbd "C-c n j") #'org-remark-change)
      )
    )
  ;; Create highlighter pens for different parts
  (with-eval-after-load 'org-remark
    ;; Since I use alternate dark and clear themes, these must be useful for both
    (org-remark-create "blue-structure"
                       '(:underline "sky blue" :background "deep sky blue")
                       '(CATEGORY "structure"))

    ;; can be properly seen in both dark and clear themes
    (org-remark-create "dark-blue-line"
                       '(:underline "deep sky blue")
                       '(CATEGORY "editing"))

    (org-remark-create "gray-plot"
                       '(:background "dim gray")
  		     '(CATEGORY "plot"))

    (org-remark-create "salmon-character"
                       '(:background "salmon")
  		     '(CATEGORY "character"))

    (org-remark-create "yellow-dialogue"
                       '(:background "yellow")
  		     '(CATEGORY "dialogue"))

    (org-remark-create "royal-blue-other"
                       '(:background "royal blue")
  		     '(CATEGORY "other"))
    )
#+end_src

** org-context-extended and org-tracktable
Here, I document all the config related to my writing.

Load the org-context-extended code, that adds helper functions and a flexible prose word count function:
#+begin_src emacs-lisp :tangle packages.el
(package! org-context-extended
    :recipe (:host codeberg :repo "jcastp/org-context-extended"))
  ;; (use-package org-context-extended
  ;;   :ensure t
  ;;   :vc (:url "https://codeberg.org/jcastp/org-context-extended"
  ;; 	    :branch "main"
  ;; 	    :rev :newest))
#+end_src

Load a custom implementation of the org-tracktable package, using the org-context-extended word counting function:
#+begin_src emacs-lisp :tangle packages.el
(package! org-tracktable
    :recipe (:host codeberg :repo "jcastp/org-tracktable"))
  ;; (use-package org-tracktable
  ;;   :ensure t
  ;;   :vc (:url "https://codeberg.org/jcastp/org-tracktable"
  ;; 	    :branch "main"
  ;; 	    :rev :newest))
#+end_src
** TODO org-scribe
Load the org-scribe package. Information is [[https://codeberg.org/jcastp/org-scribe][here]].

Load org-scribe directly from the repository to preserve directory structure:
#+begin_src emacs-lisp :tangle yes
;; Load org-scribe from local development directory
(let ((org-scribe-dir (expand-file-name "~/Nextcloud/escritura/software/org-scribe")))
  (when (file-directory-p org-scribe-dir)
    (add-to-list 'load-path org-scribe-dir)
    (require 'org-scribe))
  (global-set-key (kbd "<f8> <f8>") 'hydra-org-scribe/body))
#+end_src

** TODO org-scribe-planner
Load the org-scribe-planner package
#+begin_src emacs-lisp :tangle no
  (use-package org-scribe-planner
  :vc (:url "https://codeberg.org/jcastp/org-scribe-planner"
  	    :branch "main"
  	    :rev :newest)
  :after org)
#+end_src

** Create a story file on the fly
Sometimes I want to create a story prompt on the fly. These functions allow for creating the prompts and the file, so I can immediately start writing.

This code depends on a custom script that generates writing prompts based on a list of keywords and some templates.

#+begin_src emacs-lisp
  (defvar my-writing-stories-directory "~/Nextcloud/escritura/historias/ejercicios"
    "Directory where org files created by `my-writing/create-org-file' will be stored.")

  (defun my-writing/create-empty-writing-file (title)
    "Create a new empty org file with name format `%Y%m%d-<title>.org', where <title> is the `title' argument with spaces replaced by underscores. The file will be stored in `writing-stories-directory'."
    (interactive "sEnter file name: ")
    (let* ((date (format-time-string "%Y%m%d"))
           ;; Create the filename with the timestamp and the title
           (filename (concat date "-" (replace-regexp-in-string " " "_" title) ".org"))
           ;; create the full path of the file
           (full-path (concat my-writing-stories-directory "/" filename))
           ;; Create a string with the title and author
           (initial_title (format "#+TITLE: %s\n#+AUTHOR: %s\n#+EMAIL: %s" title user-full-name user-mail-address))
           )
      ;; very crude way to include some title in the file created
      (append-to-file initial_title nil full-path)
      (find-file full-path)
      ))

  (defun my-writing/create-writing-exercise (title)
    "Create a new file with the current date and the specified TITLE.
  The file is saved in the directory specified by `my-writing-stories-directory'.
  The file name format is \"%Y%m%d-<text>.org\", with spaces in TEXT replaced by \"_\".
  The function runs a Python script that generates a writing prompt
  and stores the output in the file."
    (interactive "sEnter file name: ")
    (let* ((date (format-time-string "%Y%m%d"))
           ;; Create the filename with the timestamp and the title
           (file-name (concat date "-" (replace-regexp-in-string " " "_" title) ".org"))
           ;; create the full path of the file
           (file-path (concat my-writing-stories-directory "/" file-name))
           ;; Get the output from the python script
           (python-output (shell-command-to-string "python  ~/Nextcloud/escritura/software/writing_companion/writing_companion.py -s all prompt"))
           ;; Create the initial org front matter
           (initial_title (format "#+TITLE: %s\n#+AUTHOR: %s\n#+EMAIL: %s" title user-full-name user-mail-address)))
      ;; insert the data in the file
      (with-temp-file file-path
        (insert initial_title )
	(insert "\n\n" python-output))
      ;; open the file
      (find-file file-path)
      ))
#+end_src

* Testing

** TODO elfeed and elfeed-org
Configuration for the elfeed and the org files.
#+begin_src emacs-lisp
;; database for elfeed
(use-package! elfeed
  :config
  (elfeed-org)
  (setq elfeed-db-directory (expand-file-name "elfeed/db/" my-data-dir))

  ;; Optionally specify a number of files containing elfeed
  ;; configuration. If not set then the location below is used.
  ;; Note: The customize interface is also supported.
  (setq rmh-elfeed-org-files (list "~/Nextcloud/config/.emacs.d/elfeed/elfeed.org"))
  ;; put the filter to 1 month ago by default
  (setq elfeed-search-set-filter "@1-month-ago")

  ;; open elfeed and update it
  (defun my/elfeed()
    "Opens elfeed and updates it in just a go."
    (interactive)
    (elfeed)
    (elfeed-update)))
#+end_src

** TODO Alternative and better C-g function
https://emacsredux.com/blog/2025/06/01/let-s-make-keyboard-quit-smarter/

#+begin_src emacs-lisp :tangle yes
(defun er-keyboard-quit-dwim ()
  "Do-What-I-Mean behaviour for a general `keyboard-quit'.

The generic `keyboard-quit' does not do the expected thing when
the minibuffer is open.  Whereas we want it to close the
minibuffer, even without explicitly focusing it.

The DWIM behaviour of this command is as follows:

- When the region is active, disable it.
- When a minibuffer is open, but not focused, close the minibuffer.
- When the Completions buffer is selected, close it.
- In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))

(global-set-key [remap keyboard-quit] #'er-keyboard-quit-dwim)
#+end_src
** TODO gptel config
Emacs config for my llama.cpp / llama.swap installation.

#+begin_src emacs-lisp :tangle yes
;; Llama.cpp offers an OpenAI compatible API
(gptel-make-openai "llama-cpp"          ;Any name
  :stream t                             ;Stream responses
  :protocol "http"
  :host "localhost:8080"                ;Llama.cpp server location
  ;Any names, doesn't matter for Llama
  :models '(llama3.1
            llama3.2
            gpt-oss
            phi4-mini-4b-augmented
            phi4-mini-4b
            phi4-reasoning
            qwen3-30b))
#+end_src

* My custom key bindings
This is where I'm going to define my own keybindings.
** Buffer related keybindings
Mapping special keybindings for buffer related functions.

#+begin_src emacs-lisp :tangle yes
(map! :leader
      (:prefix-map ("b" . "buffers")
       :desc "capture to this buffer"  "c"  #'my/capture-to-this-buffer
       :desc "switch to buffer" "b" #'switch-to-buffer
       :desc "kill buffer" "k" #'kill-current-buffer
       :desc "list buffers" "l" #'list-buffers
       :desc "ibuffer" "i" #'ibuffer
       :desc "orgmode scratch buffer" "o" #'my/scratch-org-buffer
       :desc "scratch buffer" "x" #'doom/toggle-scratch-buffer))
#+end_src

** roam related keybindings
Mapping my org roam functions:
- my random roam node
- my random todo roam node
- my agenda restricted to roam

#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "random todo roam node"      "n r t" #'my/random-roam-todo-node
      :desc "random roam node"           "n r T" #'my/random-roam-node
      :desc "roam agenda"                "n r a" #'my/agenda-restrict-to-roam)
#+end_src

** Additional keybindings

file related keybinding
#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "save buffer"      "f s" #'save-buffer)
#+end_src

Online related keybindings
#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "eww"      "o b" #'eww
      :desc "elfeed"   "o e" #'my/elfeed)
#+end_src

Outline
#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "Search outline"   "s o" #'consult-outline)
#+end_src

Fontaine - set the fonts
#+begin_src emacs-lisp :tangle yes
(map! :leader
      :desc "Change fonts"   "t o" #'fontaine-set-preset)
#+end_src

** Personal keybindings
This is reserved for additional keybindings:

#+begin_src emacs-lisp :tangle yes
(map! :leader
      (:prefix-map ("d" . "personal prefix")
                   (:prefix-map ("w" . "writing functions")
                                :desc "empty writing file" "e" #'my-writing/create-empty-writing-file
                                :desc "writing exercise" "w" #'my-writing/create-writing-exercise
                                )
                   )
      )
#+end_src

* Work environment
This will be my working environment config

#+begin_src emacs-lisp
;; Load this config when using the work computer
(if my-workenvironment-p
    (progn
      (org-babel-load-file "~/.doom.d/emacs-org-init-trabajo.org")))
#+end_src

# Local Variables:
# ispell-local-dictionary: "en_US"
# End:
